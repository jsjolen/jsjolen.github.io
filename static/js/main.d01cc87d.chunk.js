(this["webpackJsonpjsjolen.github.io"]=this["webpackJsonpjsjolen.github.io"]||[]).push([[0],{104:function(e,n){},311:function(e,n,t){},314:function(e,n,t){"use strict";t.r(n);var i=t(0),r=t(1),s=t.n(r),c=t(74),a=t.n(c),l=t(21),o=t(4);function d(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Relational Symbolic Execution in WebAssembly"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Abstract"}),Object(i.jsx)("p",{className:"centered-limited",children:"WebAssembly is a new low-level language used as a compilation target which runs in web browsers. As more code is run on the client side of a web application the issue of security of that code become more important. Our work is based in the approach of using formal verification in order to prove that for a program one or more security properties hold. In this thesis we have explored the usage of relational symbolic execution in order to perform formal verification of security properties for WebAssembly programs. We described a formal semantics of relational symbolic execution for WebAssembly, implemented it in the Redex framework, extended the implementation for verification of constant-time security, and used the implementation to formally verify multiple sample programs including Salsa20. Our work shows that relational verification of standard security properties such as non-interference and constant-time security by using relational symbolic execution for WebAssembly is a viable approach."}),Object(i.jsx)("a",{className:"center",href:"https://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A1471675&dswid=4728",children:"Available from DiVA here"}),Object(i.jsx)("a",{className:"center",href:"https://github.com/jsjolen/relsym-wasm",children:"Source code available here"})]})}function h(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Probabilistic Least-violating Control Strategy Synthesis with Safety Rules"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Abstract"}),Object(i.jsx)("p",{className:"centered-limited",children:'We consider the problem of automatic control strategy synthesis for discrete models of robotic systems, where the goal is to travel from some region to another while obeying a given set of safety rules in an environment with uncertain properties. This is a probabilistic extension of the work by Jana Tumov\xe1 et al.  that is able to handle uncertainty by modifying the least-violating strategy synthesis algorithm. The first novel contribution is a way of modelling uncertain events in a map as a Markov decision process with a specific structure, using what we call "Ghost States". We then introduce a way of constructing a Product Automaton analogous to the original work, on which a modified probabilistic version of Dijkstra\'s algorithm can be run to synthesize the least-violating plan. The result is a synthesis algorithm that works similarly to the original, but can handle probabilistic uncertainty. It could be used in cases where e.g. uncertain weather conditions or the behaviour of external actors can be modelled as stochastic variables.'}),Object(i.jsx)("a",{className:"center",href:"https://kth.diva-portal.org/smash/record.jsf?dswid=-5756&pid=diva2%3A1215050",children:"Available from DiVA here"})]})}t(60);function u(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("header",{children:Object(i.jsx)("h1",{style:{margin:"2em"},children:"Johan Sj\xf6l\xe9n"})}),Object(i.jsx)("h3",{className:"centered-limited",children:"Welcome "}),Object(i.jsx)("p",{className:"centered-limited",children:"I'm a software engineer with a MSc from KTH Royal Institute of Technology (also civilingenj\xf6r for any Swede out there). I have a wide array of interests including but not limited to the following."}),Object(i.jsxs)("ul",{className:"centered-limited",children:[Object(i.jsx)("li",{children:"Compilers and PL theory"}),Object(i.jsx)("li",{children:"Formal methods"}),Object(i.jsx)("li",{children:"Security"}),Object(i.jsx)("li",{children:"Distributed systems"}),Object(i.jsx)("li",{children:"Functional programming"})]}),Object(i.jsx)("p",{className:"centered-limited",children:"On this page you will find any work I've done pertaining to these topics. You may contact me at: johan.borglin.sjolen at gmail dot com."})]})}var m=t(14),b=t(50),p=t(75),j=t(48),x=new p.Grammars.W3C.Parser('\nProgram         ::= WS* VarDecl* WS* Thread* WS*\nThread          ::= WS* "thread " WS* Var WS* "{" WS* (IfStmt | AssStmt | LockStmt | UnlockStmt)* WS* "}" WS*\nVarDecl         ::= IntDecl | VolatileIntDecl | LockDecl\nIntDecl         ::= "int" WS* Var " = " Expr ";" WS*\nVolatileIntDecl ::= "volatile int" WS* Var " = " Expr ";" WS*\nLockDecl        ::= "lock" WS* Var ";" WS*\nIfStmt          ::= WS* "if" WS* "(" WS* CmpExpr WS* ")" WS* "{" Body "}" WS* "else" WS* "{" WS* Body "}" WS*\nBody            ::= WS* (IfStmt | AssStmt | LockStmt | UnlockStmt)* WS*\nAssStmt         ::= Var " = " Expr ";" WS*\nLockStmt        ::= Var ".lock()" ";" WS*\nUnlockStmt      ::= Var ".unlock()" ";" WS*\n\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr "+" Expr\nCmpExpr         ::= Expr "==" Expr | Expr ">" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\nNUMBER          ::= "-"? ("0" | [1-9] [0-9]*) ("." [0-9]+)? (("e" | "E") ( "-" | "+" )? ("0" | [1-9] [0-9]*))?\nWS              ::= [#x20#x09#x0A#x0D]+\n');function f(e){var n=e.children.reduce((function(e,n){var t=Object(m.a)(e,2),i=t[0],r=t[1];switch(n.type){case"VarDecl":return i.push(n),[i,r];case"Thread":return r.push(n),[i,r];default:throw new Error("no way!")}}),[[],[]]),t=Object(m.a)(n,2),i=t[0],r=t[1],s={self:i[0],prev:null,next:[]},c=i.slice(1).reduce((function(e,n){var t=y(n,e);return e.next.push(t),t}),s),a=new Array;return r.forEach((function(e){var n={self:e,prev:null,next:[]};n.next.push(y(e,n)),a.push(n);var t={self:e,prev:c,next:[]};c.next.push(t),c=t})),[s,a]}function y(e,n){switch(e.type){case"Thread":var t={self:e.children[1],prev:n,next:[]};return e.children.slice(2).reduce((function(e,n){var t=y(n,e);return e.next.push(t),t}),t),t;case"IfStmt":var i={self:e.children[0],prev:n,next:[]},r={self:e.children[1],prev:i,next:[]},s={self:e.children[2],prev:i,next:[]};return i.next.push(r),i.next.push(s),r.self.children.reduce((function(e,n){var t=y(n,e);return e.next.push(t),t}),r),s.self.children.reduce((function(e,n){var t=y(n,e);return e.next.push(t),t}),s),i;case"VarDecl":case"AssStmt":case"LockStmt":case"Expr":case"Var":case"UnlockStmt":return{self:e,prev:n,next:[]}}throw console.log(e),new Error("Did not match!")}function O(e){var n=Object(m.a)(e,2),t=n[0],i=n[1],r=g(t,0),s=Object(m.a)(r,2),c=s[0],a=s[1];return"digraph G {\n"+c+i.reduce((function(e,n){var t=Object(m.a)(e,2),i=t[0],r=g(n,t[1]),s=Object(m.a)(r,2);return[i+s[0],s[1]+1]}),["",a+1])[0]+"\n}"}function g(e,n){for(var t="",i=new Array,r=new Array,s=function e(n,t){var s=t;if("Thread"===n.self.type?i.push("node".concat(t,' [label="Thread ').concat(n.self.children[0].text,' start" shape=plaintext]')):"Body"===n.self.type?i.push("node".concat(t,' [label="').concat(n.self.children[0].text,'" shape=plaintext]')):i.push("node".concat(t,' [label="').concat(n.self.text.trim(),'" shape=plaintext]')),"CmpExpr"===n.self.type){var c=t+1;r.push("node".concat(s," -> node").concat(c,' [label="true"]'));var a=(t=e(n.next[0],c))+1;r.push("node".concat(s," -> node").concat(a,' [label="false"]')),t=e(n.next[1],a)}else if("Body"===n.self.type){var l,o=Object(b.a)(n.next.splice(1));try{for(o.s();!(l=o.n()).done;){var d=l.value,h=t+1;d.self.type,r.push("node".concat(s," -> node").concat(h)),t=e(d,h)}}catch(x){o.e(x)}finally{o.f()}}else{var u,m=Object(b.a)(n.next);try{for(m.s();!(u=m.n()).done;){var p=u.value,j=t+1;p.self.type,r.push("node".concat(s," -> node").concat(j)),t=e(p,j)}}catch(x){m.e(x)}finally{m.f()}}return t}(e,n),c=0,a=i;c<a.length;c++){t+=a[c]+"\n"}for(var l=0,o=r;l<o.length;l++){t+=o[l]+"\n"}return[t,s]}console.log(f(x.getAST("\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n        y = 0;\n    }\n    else {\n       y = 2;\n       y = 0;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n","Program"))),console.log(O(f(x.getAST("\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n        y = 0;\n}\n    else {\n       y = 2;\ny = 0;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n","Program")))),console.log(f(x.getAST("\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n","Program")));var S="\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n",v=O(f(x.getAST(S,"Program")));function w(e){var n=Object(r.useState)({active:!1}),t=Object(m.a)(n,2),s=t[0],c=t[1];return Object(i.jsx)("button",{className:s.active?"pure-button pure-button-primary":"pure-button pure-button-primary pure-button-active",onClick:function(){c({active:!s.active}),e.onClick()},children:e.text})}function A(){var e=Object(r.useState)(v),n=Object(m.a)(e,2),t=n[0],s=n[1],c=Object(r.useRef)(null);return Object(i.jsxs)("div",{className:"centered-limited",style:{display:"flex",flexDirection:"column"},children:[Object(i.jsxs)("div",{style:{display:"flex",flexDirection:"row"},children:[Object(i.jsx)("textarea",{ref:c,rows:20,cols:20,value:S}),Object(i.jsx)(j.a,{dot:t})]}),Object(i.jsx)(w,{text:"Render program order",onClick:function(){try{if(c.current){var e=O(f(function(e){var n;if("Thread"===(null===(n=e.children[0])||void 0===n?void 0:n.type))throw new Error("Must define at least 1 variable");if(e.children.findIndex((function(e){return"Thread"===e.type}))<0)throw new Error("Must define at least 1 thread");return e}(x.getAST(c.current.value,"Program"))));s(e)}}catch(n){}}})]})}function k(){return Object(i.jsxs)("pre",{className:"centered-limited",children:[" ",Object(i.jsx)("code",{children:'\nProgram         ::=  VarDecl*  Thread*\nThread          ::=  "thread "  Var  "{"  (IfStmt | AssStmt | LockStmt | UnlockStmt)*  "}"\nVarDecl         ::= IntDecl | VolatileIntDecl | LockDecl\nIntDecl         ::= "int"  Var " = " Expr ";"\nVolatileIntDecl ::= "volatile int"  Var " = " Expr ";"\nLockDecl        ::= "lock"  Var ";"\nIfStmt          ::=  "if"  "("  CmpExpr  ")"  "{" Body "}"  "else"  "{"  Body "}"\nBody            ::=  (IfStmt | AssStmt | LockStmt | UnlockStmt)*\nAssStmt         ::= Var " = " Expr ";"\nLockStmt        ::= Var ".lock()" ";"\nUnlockStmt      ::= Var ".unlock()" ";"\n\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr "+" Expr\nCmpExpr         ::= Expr "==" Expr | Expr ">" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\nNUMBER          ::= "-"? ("0" | [1-9] [0-9]*) ("." [0-9]+)? (("e" | "E") ( "-" | "+" )? ("0" | [1-9] [0-9]*))?\n'})," "]})}function N(e){return Object(i.jsxs)("pre",{className:"centered-limited",children:[" ",Object(i.jsxs)("code",{className:"centered-limited",children:[" ",e.children," "]})," "]})}function I(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Interactive Java Memory Model"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Introduction"}),Object(i.jsxs)("p",{className:"centered-limited",children:["The Java Memory Model (JMM) is a formalism which reduces the set of possible execution traces for Java programs. This is meant to allow for users and implementers to reason about concurrent programs.",Object(i.jsx)("a",{href:"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html",children:"JLS chapter 17"})," defines the JMM. I personally did not find it very easy to grok this particular part of the spec. To solve this for me and for others I decided to implement a tool for exploring a limited form of the JMM that can run on the web. That is what this page is for :-)."]}),Object(i.jsx)("h3",{className:"centered-limited",children:"The language"}),Object(i.jsx)("p",{className:"centered-limited",children:"We will be considering a much smaller language than Java for simplicity. We will exclude loops and recursion, and we will not allow dynamically spawning threads. However we will support locks and volatile and non-volatile ints as shared memory. The abstract grammar for the language is the following."}),Object(i.jsx)(k,{}),Object(i.jsx)("h3",{className:"centered-limited",children:"Program order"}),Object(i.jsx)(A,{}),Object(i.jsx)("h3",{className:"centered-limited",children:"Inter-thread actions and synchronization actions"}),Object(i.jsxs)("p",{className:"centered-limited",children:["An ",Object(i.jsx)("i",{children:"inter-thread action"})," is something that happens that another thread can detect or influence. Consider the following program"]}),Object(i.jsx)(N,{children:"int x = 0;\n      thread A {\n        x = 1;\n      }\n      thread B {\n        if(x == 0) {\n        } else {\n  \t// We detected a change\n        }\n     }"}),Object(i.jsx)("p",{className:"centered-limited",children:"Here thread A produces a write event and thread B produces a read event. On top of regular actions there are also synchronization actions. What follows is a list of the actions we will consider, then we will consider synchronization order."}),Object(i.jsx)("h3",{className:"centered-limited",children:"Synchronization order"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Happens Before order"}),"TODO"]})}var B=t(321),T=t(320);function L(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Structural subtyping"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Introduction"}),Object(i.jsxs)("p",{className:"centered-limited",children:["I was bored one day and thought about structural typing. Specifically, how does the type checker produce a proof that some type ",Object(i.jsx)("i",{children:"a"})," is a subtype of some other type ",Object(i.jsx)("i",{children:"b"}),"? In a nominal type system this is as easy as checking if the definition of ",Object(i.jsx)("i",{children:"a"})," mentions that it extends ",Object(i.jsx)("i",{children:"b"}),". In a structural one it becomes more complex, as we must prove that ",Object(i.jsx)("i",{children:"a"})," has the same structure as ",Object(i.jsx)("i",{children:"b"}),". This is slightly tricky when mutually recursive structures are considered. This is a fun exercise! Below is my solution in Haskell."]}),Object(i.jsx)("h3",{className:"centered-limited",children:"The language"}),Object(i.jsxs)("p",{className:"centered-limited",children:["I won't give a formal grammar, but our type language supports the following:",Object(i.jsxs)("ul",{children:[Object(i.jsxs)("li",{children:[" Unions: ",Object(i.jsx)("i",{children:"t"})," := a|b  "]}),Object(i.jsxs)("li",{children:[" Records: ",Object(i.jsx)("i",{children:"t"})," := a x b "]}),Object(i.jsxs)("li",{children:[" Primitive types: ",Object(i.jsx)("i",{children:"int"}),", ",Object(i.jsx)("i",{children:"null"})," "]})]}),"A linked list can be defined as: ",Object(i.jsx)("i",{children:"LinkedList"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LinkedList"}),"."]}),Object(i.jsx)("h3",{className:"centered-limited",children:"The solution"}),Object(i.jsxs)("p",{className:"centered-limited",children:["As most things in life all that is required is the correct perspective. We will consider types as references to vertices in a sort of directed graph or state machine. The vertices are either boxes, circles, or octagons with text in them. Circles represent unions (or primitive types), boxes records. The octagons and dashed lines are named references. To check if ",Object(i.jsx)("i",{children:"a"})," ","\u2264"," ",Object(i.jsx)("i",{children:"b"})," is equivalent to checking if a particular trace exists in both ",Object(i.jsx)("i",{children:"a"})," and ",Object(i.jsx)("i",{children:"b"}),". Consider the following types:",Object(i.jsxs)("ul",{className:"empty",children:[Object(i.jsxs)("li",{children:[" ",Object(i.jsx)("i",{children:"LinkedList"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LinkedList"})," "]}),Object(i.jsxs)("li",{children:[" ",Object(i.jsx)("i",{children:"LLInner"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LLOuter"}),"  "]}),Object(i.jsxs)("li",{children:[" ",Object(i.jsx)("i",{children:"LLOuter"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LLInner"}),"  "]})]}),"Is ",Object(i.jsx)("i",{children:"LinkedList"})," \u2264 ",Object(i.jsx)("i",{children:"LLInner"}),"?"]}),Object(i.jsx)("p",{className:"centered-limited",children:"To answer this question we must first compute the type graph of this instance."}),Object(i.jsx)("div",{className:"centered-limited",style:{display:"flex",flexDirection:"column"},children:Object(i.jsx)(j.a,{dot:'\ndigraph G {\n    int [label="int"];\n    null [label="null"];\n    llunion [label="", shape=circle];\n    llrecord [label="", shape=box];\n    innerunion [label="", shape=circle];\n    innerrecord [label="", shape=box];\n    outerunion [label="", shape=circle];\n    outerrecord [label="", shape=box];\n\n    LinkedList[shape=octagon]\n    LLInner[shape=octagon]\n    LLOuter[shape=octagon]\n\n    llunion -> null;\n    llunion -> llrecord;\n    llrecord -> llunion;\n    llrecord -> int;\n\n    innerunion -> null;\n    innerunion -> innerrecord;\n    innerrecord -> int;\n    innerrecord -> outerunion;\n\n    outerunion -> null;\n    outerunion -> outerrecord;\n    outerrecord -> int;\n    outerrecord -> innerunion;\n\n    LLOuter -> outerunion [style=dashed];\n    LLInner -> innerunion [style=dashed];\n    LinkedList -> llunion [style=dashed];\n}\n'})}),Object(i.jsxs)("p",{className:"centered-limited",children:["We defined this graph in Haskell utilising algebraic data types with ids for labelling unique vertices. The idea is pretty simple. Essentially for ",Object(i.jsx)("i",{children:"a"})," ","\u2264"," ",Object(i.jsx)("i",{children:"b"})," then we must be able to take lock-step identical steps in each data structure until we are in a state in both ",Object(i.jsx)("i",{children:"a"})," and ",Object(i.jsx)("i",{children:"b"})," where we've been before. Since ",Object(i.jsx)("i",{children:"b"})," must be a superset of ",Object(i.jsx)("i",{children:"a"})," we let ",Object(i.jsx)("i",{children:"a"})," decide which next step to take."]}),Object(i.jsx)(B.a,{className:"centered-limited",language:"haskell",style:T.a,children:"\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE StandaloneDeriving #-}\nimport qualified Data.Set as Set\nimport Debug.Trace\n\ndata StructuralType =\n  Union [StructuralType] Integer\n  | Record [StructuralType] Integer\n  | Int Integer\n  | Null Integer\nderiving instance Eq StructuralType\nderiving instance Ord StructuralType\n\n-- Avoid infinite recursion by not inspecting middle argument.\ninstance Show StructuralType where\n    show (Union _ id) = \"Union \" ++ (show id)\n    show (Record _ id) = \"Record \" ++ (show id)\n    show (Int id) = \"Int \" ++ (show id)\n    show (Null id) = \"Null \" ++ (show id)\n\nintt = Int 0\nnullt = Null 1\nlinkedList =\n  let node = Union [nullt, Record [intt, node] 3] 2\n  in node\ninode = Union [nullt, Record [intt, onode] 5] 4\nonode = Union [nullt, Record [intt, inode] 7] 6\ninnerList = inode\nouterList = onode\n\ntmember :: StructuralType -> Set.Set Integer -> Bool\ntmember (Record _ id) set = Set.member id set\n-- Remainder omitted for brevity\n\ntinsert :: StructuralType -> Set.Set Integer -> Set.Set Integer\ntinsert (Record _ id) set = Set.insert id set\n-- Remainder omitted for brevity\n\n-- Requires identical ordering of elements\nisSubtypeOf\n  :: StructuralType ->\n     StructuralType ->\n     Set.Set Integer ->\n     Set.Set Integer ->\n     (Bool, Set.Set Integer, Set.Set Integer)\nisSubtypeOf (Union tsA i) (Union tsB i') seenA seenB =\n  foldl ((subtype, seenA', seenB') (a,b) ->\n           if (tmember a seenA' && tmember b seenB') then (subtype, seenA', seenB') else\n             let (subtype', seenA'', seenB'') = isSubtypeOf a b seenA' seenB'\n             in (subtype' && subtype, seenA'', seenB''))\n        (True,Set.insert i seenA, Set.insert i' seenB) $ zip tsA tsB\nisSubtypeOf (Record tsA i) (Record tsB i') seenA seenB = \n  foldl ((subtype, seenA', seenB') (a,b) ->\n           if (tmember a seenA' && tmember b seenB') then (subtype, seenA', seenB') else\n             let (subtype', seenA'', seenB'') = isSubtypeOf a b seenA' seenB'\n             in (subtype' && subtype, seenA'', seenB''))\n        (True,Set.insert i seenA, Set.insert i' seenB) $ zip tsA tsB\nisSubtypeOf (Int ida) (Int idb) seenA seenB =\n  let seenA' = Set.insert ida seenA\n      seenB' = Set.insert idb seenB\n  in (True, seenA', seenB')\nisSubtypeOf (Null ida) (Null idb) seenA seenB =\n  let seenA' = Set.insert ida seenA\n      seenB' = Set.insert idb seenB\n  in (True, seenA', seenB')\nisSubtypeOf a b seenA seenB = (False, seenA, seenB)\n"})]})}var E=function(){return Object(r.useEffect)((function(){document.title="A page."})),Object(i.jsxs)(l.a,{children:[Object(i.jsxs)("ul",{className:"pure-menu-horizontal",children:[Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(l.b,{className:"pure-menu-link",to:"/",children:"Home"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(l.b,{className:"pure-menu-link",to:"/relsymwasm",children:"MSc thesis"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(l.b,{className:"pure-menu-link",to:"/bsc",children:"BSc thesis"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(l.b,{className:"pure-menu-link",to:"/jmm",children:"JMM (WIP)"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(l.b,{className:"pure-menu-link",to:"/structuraltyping",children:"Structural typing"})})]}),Object(i.jsxs)(o.c,{children:[Object(i.jsx)(o.a,{exact:!0,path:"/relsymwasm",component:d}),Object(i.jsx)(o.a,{exact:!0,path:"/bsc",component:h}),Object(i.jsx)(o.a,{exact:!0,path:"/jmm",component:I}),Object(i.jsx)(o.a,{exact:!0,path:"/structuraltyping",component:L}),Object(i.jsx)(o.a,{exact:!0,path:"/",component:u})]})]})};t(311);a.a.render(Object(i.jsx)(s.a.StrictMode,{children:Object(i.jsx)(E,{})}),document.getElementById("root"))},60:function(e,n,t){},71:function(e,n){},72:function(e,n){}},[[314,1,2]]]);
//# sourceMappingURL=main.d01cc87d.chunk.js.map