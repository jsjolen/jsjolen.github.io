(this["webpackJsonpjsjolen.github.io"]=this["webpackJsonpjsjolen.github.io"]||[]).push([[0],{22:function(e,t,n){},53:function(e,t,n){},54:function(e,t,n){"use strict";n.r(t);var r=n(0),i=n(1),s=n.n(i),a=n(27),o=n.n(a),c=n(7),l=n(3);function h(){return Object(r.jsxs)("div",{children:[Object(r.jsx)("h2",{className:"center",children:"Relational Symbolic Execution in WebAssembly"}),Object(r.jsx)("h3",{className:"centered-limited",children:"Abstract"}),Object(r.jsx)("p",{className:"centered-limited",children:"WebAssembly is a new low-level language used as a compilation target which runs in web browsers. As more code is run on the client side of a web application the issue of security of that code become more important. Our work is based in the approach of using formal verification in order to prove that for a program one or more security properties hold. In this thesis we have explored the usage of relational symbolic execution in order to perform formal verification of security properties for WebAssembly programs. We described a formal semantics of relational symbolic execution for WebAssembly, implemented it in the Redex framework, extended the implementation for verification of constant-time security, and used the implementation to formally verify multiple sample programs including Salsa20. Our work shows that relational verification of standard security properties such as non-interference and constant-time security by using relational symbolic execution for WebAssembly is a viable approach."}),Object(r.jsx)("a",{className:"center",href:"https://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A1471675&dswid=4728",children:"Available from DiVA here"})]})}function d(){return Object(r.jsxs)("div",{children:[Object(r.jsx)("h2",{className:"center",children:"Probabilistic Least-violating Control Strategy Synthesis with Safety Rules"}),Object(r.jsx)("h3",{className:"centered-limited",children:"Abstract"}),Object(r.jsx)("p",{className:"centered-limited",children:'We consider the problem of automatic control strategy synthesis for discrete models of robotic systems, where the goal is to travel from some region to another while obeying a given set of safety rules in an environment with uncertain properties. This is a probabilistic extension of the work by Jana Tumov\xe1 et al.  that is able to handle uncertainty by modifying the least-violating strategy synthesis algorithm. The first novel contribution is a way of modelling uncertain events in a map as a Markov decision process with a specific structure, using what we call "Ghost States". We then introduce a way of constructing a Product Automaton analogous to the original work, on which a modified probabilistic version of Dijkstra\'s algorithm can be run to synthesize the least-violating plan. The result is a synthesis algorithm that works similarly to the original, but can handle probabilistic uncertainty. It could be used in cases where e.g. uncertain weather conditions or the behaviour of external actors can be modelled as stochastic variables.'}),Object(r.jsx)("a",{className:"center",href:"https://kth.diva-portal.org/smash/record.jsf?dswid=-5756&pid=diva2%3A1215050",children:"Available from DiVA here"})]})}n(22);function m(){return Object(r.jsxs)("div",{children:[Object(r.jsx)("header",{children:Object(r.jsx)("h1",{style:{margin:"2em"},children:"Johan Sj\xf6l\xe9n"})}),Object(r.jsx)("h3",{className:"centered-limited",children:"Welcome "}),Object(r.jsx)("p",{className:"centered-limited",children:"I'm a software engineer with a MSc from KTH Royal Institute of Technology (also civilingenj\xf6r for any Swede out there). I have a wide array of interests including but not limited to the following."}),Object(r.jsxs)("ul",{className:"centered-limited",children:[Object(r.jsx)("li",{children:"Compilers and PL theory"}),Object(r.jsx)("li",{children:"Formal methods"}),Object(r.jsx)("li",{children:"Security"}),Object(r.jsx)("li",{children:"Distributed systems"}),Object(r.jsx)("li",{children:"Functional programming"})]}),Object(r.jsx)("p",{className:"centered-limited",children:"On this page you will find any work I've done pertaining to these topics. You may contact me at: johan.borglin.sjolen at gmail dot com."})]})}var u=new(n(28).Grammars.W3C.Parser)('\nProgram     ::= WS* VarDecl* WS* Thread* WS*\nThread      ::= WS* "thread " WS* Var WS* "{" WS* Stmt* WS* "}" WS*\nVarDecl     ::= ("volatile int"|"int") WS* Var " = " Expr ";" WS* | "lock" WS* Var ";" WS*\n\nStmt        ::= (IfStmt | AssStmt | LockStmt | UnlockStmt)\nIfStmt      ::= WS* "if" WS* "(" WS* CmpExpr WS* ")" WS* "{" WS* Stmt* WS* "}" WS* "else" WS* "{" WS* Stmt* WS* "}" WS*\nAssStmt     ::= Var " = " Expr ";" WS*\nLockStmt    ::= Var ".lock()" ";" WS*\nUnlockStmt  ::= Var ".unlock()" ";" WS*\n\nExpr        ::= Var | Value | CmpExpr | AddExpr\nAddExpr     ::= Expr "+" Expr\nCmpExpr      ::= Expr "==" Expr | Expr ">" Expr\nVar         ::= ([a-z]|[A-Z])+\nValue       ::= NUMBER\n\nNUMBER      ::= "-"? ("0" | [1-9] [0-9]*) ("." [0-9]+)? (("e" | "E") ( "-" | "+" )? ("0" | [1-9] [0-9]*))?\nWS          ::= [#x20#x09#x0A#x0D]+\n');function p(e,t){switch(e.type){case"Program":return e.children.slice(1).reduce((function(e,t){var n=p(t,e);return e.next.push(n),n}),{self:e.children[0],prev:t,next:[]});case"Thread":return e.children.slice(1).reduce((function(e,t){var n=p(t,e);return e.next.push(n),n}),{self:e,prev:t,next:[]});case"IfStmt":var n={self:e.children[0],prev:t,next:[]},r={self:e.children[1],prev:n,next:[]},i={self:e.children[2],prev:n,next:[]};return n.next.push(r),n.next.push(i),e.children[1].children.reduce((function(e,t){var n=p(t,e);return e.next.push(n),n}),r),e.children[2].children.reduce((function(e,t){var n=p(t,e);return e.next.push(n),n}),i),n;case"VarDecl":case"AssStmt":case"LockStmt":case"UnlockStmt":case"Stmt":return{self:e,prev:t,next:[]}}throw new Error("Did not match!")}function j(){return Object(r.jsx)("p",{children:"TODO"})}function b(){return Object(r.jsxs)("div",{children:[Object(r.jsx)("h2",{className:"center",children:"Interactive Java Memory Model"}),Object(r.jsx)("h3",{className:"centered-limited",children:"Introduction"}),Object(r.jsxs)("p",{className:"centered-limited",children:["The Java Memory Model (JMM) is a formalism which reduces the set of possible execution traces for Java programs. This is meant to allow for users and implementers to reason about concurrent programs.",Object(r.jsx)("a",{href:"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html",children:"JLS chapter 17"})," defines the JMM. I personally did not find it very easy to grok this particular part of the spec. To solve this for me and for others I decided to implement a tool for exploring a limited form of the JMM that can run on the web. That is what this page is for :-)."]}),Object(r.jsx)("h3",{className:"centered-limited",children:"The language"}),Object(r.jsx)("p",{className:"centered-limited",children:"We will be considering a much smaller language than Java for simplicity. We will exclude loops and recursion, and we will not allow dynamically spawning threads. However we will support locks and volatile and non-volatile ints as shared memory. The abstract grammar for the language is the following."}),Object(r.jsx)(j,{}),Object(r.jsx)("h3",{className:"centered-limited",children:"Program order"}),"TODO",Object(r.jsx)("h3",{className:"centered-limited",children:"Synchronization actions"}),"TODO",Object(r.jsx)("h3",{className:"centered-limited",children:"Happens Before order"}),"TODO"]})}console.log(u.getAST("5","Value")),console.log(u.getAST("x","Var")),console.log(u.getAST("volatile int x = 5;","VarDecl")),console.log(u.getAST("\nthread A {\n    x = 5;\n    y = 6;\n}\n","Thread")),console.log(u.getAST("\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n","IfStmt")),console.log(u.getAST("\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n","Program")),console.log(p(u.getAST("volatile int x = 5;","VarDecl"),{self:"START",prev:null,next:[]})),console.log(p(u.getAST("\nthread A {\n    x = 5;\n    y = 6;\n}\n","Thread"),{self:"START",prev:null,next:[]})),console.log(p(u.getAST("\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n","Program"),{self:"START",prev:null,next:[]}));var x=function(){return Object(i.useEffect)((function(){document.title="A page."})),Object(r.jsxs)(c.a,{children:[Object(r.jsxs)("ul",{className:"pure-menu-horizontal",children:[Object(r.jsx)("li",{className:"pure-menu-item",children:Object(r.jsx)(c.b,{className:"pure-menu-link",to:"/",children:"Home"})}),Object(r.jsx)("li",{className:"pure-menu-item",children:Object(r.jsx)(c.b,{className:"pure-menu-link",to:"/relsymwasm",children:"MSc thesis"})}),Object(r.jsx)("li",{className:"pure-menu-item",children:Object(r.jsx)(c.b,{className:"pure-menu-link",to:"/bsc",children:"BSc thesis"})}),Object(r.jsx)("li",{className:"pure-menu-item",children:Object(r.jsx)(c.b,{className:"pure-menu-link",to:"/jmm",children:"JMM"})})]}),Object(r.jsxs)(l.c,{children:[Object(r.jsx)(l.a,{exact:!0,path:"/relsymwasm",component:h}),Object(r.jsx)(l.a,{exact:!0,path:"/bsc",component:d}),Object(r.jsx)(l.a,{exact:!0,path:"/jmm",component:b}),Object(r.jsx)(l.a,{exact:!0,path:"/",component:m})]})]})};n(53);o.a.render(Object(r.jsx)(s.a.StrictMode,{children:Object(r.jsx)(x,{})}),document.getElementById("root"))}},[[54,1,2]]]);
//# sourceMappingURL=main.7b57ca7a.chunk.js.map