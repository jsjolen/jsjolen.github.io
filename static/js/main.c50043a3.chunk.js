(this["webpackJsonpjsjolen.github.io"]=this["webpackJsonpjsjolen.github.io"]||[]).push([[0],{106:function(e,t){},313:function(e,t,n){},315:function(e,t,n){"use strict";n.r(t);var i=n(0),s=n(1),r=n.n(s),a=n(74),l=n.n(a),c=n(14),o=n(4);function d(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Relational Symbolic Execution in WebAssembly"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Abstract"}),Object(i.jsx)("p",{className:"centered-limited",children:"WebAssembly is a new low-level language used as a compilation target which runs in web browsers. As more code is run on the client side of a web application the issue of security of that code become more important. Our work is based in the approach of using formal verification in order to prove that for a program one or more security properties hold. In this thesis we have explored the usage of relational symbolic execution in order to perform formal verification of security properties for WebAssembly programs. We described a formal semantics of relational symbolic execution for WebAssembly, implemented it in the Redex framework, extended the implementation for verification of constant-time security, and used the implementation to formally verify multiple sample programs including Salsa20. Our work shows that relational verification of standard security properties such as non-interference and constant-time security by using relational symbolic execution for WebAssembly is a viable approach."}),Object(i.jsx)("a",{className:"center",href:"https://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A1471675&dswid=4728",children:"Available from DiVA here"}),Object(i.jsx)("a",{className:"center",href:"https://github.com/jsjolen/relsym-wasm",children:"Source code available here"})]})}function h(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Probabilistic Least-violating Control Strategy Synthesis with Safety Rules"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Abstract"}),Object(i.jsx)("p",{className:"centered-limited",children:'We consider the problem of automatic control strategy synthesis for discrete models of robotic systems, where the goal is to travel from some region to another while obeying a given set of safety rules in an environment with uncertain properties. This is a probabilistic extension of the work by Jana Tumov\xe1 et al.  that is able to handle uncertainty by modifying the least-violating strategy synthesis algorithm. The first novel contribution is a way of modelling uncertain events in a map as a Markov decision process with a specific structure, using what we call "Ghost States". We then introduce a way of constructing a Product Automaton analogous to the original work, on which a modified probabilistic version of Dijkstra\'s algorithm can be run to synthesize the least-violating plan. The result is a synthesis algorithm that works similarly to the original, but can handle probabilistic uncertainty. It could be used in cases where e.g. uncertain weather conditions or the behaviour of external actors can be modelled as stochastic variables.'}),Object(i.jsx)("a",{className:"center",href:"https://kth.diva-portal.org/smash/record.jsf?dswid=-5756&pid=diva2%3A1215050",children:"Available from DiVA here"})]})}n(60);function u(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("header",{children:Object(i.jsx)("h1",{style:{margin:"2em"},children:"Johan Sj\xf6l\xe9n"})}),Object(i.jsx)("h3",{className:"centered-limited",children:"Welcome "}),Object(i.jsx)("p",{className:"centered-limited",children:"I'm a software engineer with a MSc from KTH Royal Institute of Technology (also civilingenj\xf6r for any Swede out there). I have a wide array of interests including but not limited to the following."}),Object(i.jsxs)("ul",{className:"centered-limited",children:[Object(i.jsx)("li",{children:"Compilers and PL theory"}),Object(i.jsx)("li",{children:"Formal methods"}),Object(i.jsx)("li",{children:"Security"}),Object(i.jsx)("li",{children:"Distributed systems"}),Object(i.jsx)("li",{children:"Functional programming"})]}),Object(i.jsx)("p",{className:"centered-limited",children:"On this page you will find any work I've done pertaining to these topics. You may contact me at: johan.borglin.sjolen at gmail dot com."})]})}var m=n(15),p=n(50),b=n(75),f=n(48),j=new b.Grammars.W3C.Parser('\nProgram         ::= WS* VarDecl* WS* Thread* WS*\nThread          ::= WS* "thread " WS* Var WS* "{" WS* (IfStmt | AssStmt | LockStmt | UnlockStmt)* WS* "}" WS*\nVarDecl         ::= IntDecl | VolatileIntDecl | LockDecl\nIntDecl         ::= "int" WS* Var " = " Expr ";" WS*\nVolatileIntDecl ::= "volatile int" WS* Var " = " Expr ";" WS*\nLockDecl        ::= "lock" WS* Var ";" WS*\nIfStmt          ::= WS* "if" WS* "(" WS* CmpExpr WS* ")" WS* "{" Body "}" WS* "else" WS* "{" WS* Body "}" WS*\nBody            ::= WS* (IfStmt | AssStmt | LockStmt | UnlockStmt)* WS*\nAssStmt         ::= Var " = " Expr ";" WS*\nLockStmt        ::= Var ".lock()" ";" WS*\nUnlockStmt      ::= Var ".unlock()" ";" WS*\n\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr "+" Expr\nCmpExpr         ::= Expr "==" Expr | Expr ">" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\nNUMBER          ::= "-"? ("0" | [1-9] [0-9]*) ("." [0-9]+)? (("e" | "E") ( "-" | "+" )? ("0" | [1-9] [0-9]*))?\nWS              ::= [#x20#x09#x0A#x0D]+\n');function x(e){var t=e.children.reduce((function(e,t){var n=Object(m.a)(e,2),i=n[0],s=n[1];switch(t.type){case"VarDecl":return i.push(t),[i,s];case"Thread":return s.push(t),[i,s];default:throw new Error("no way!")}}),[[],[]]),n=Object(m.a)(t,2),i=n[0],s=n[1],r={self:i[0],prev:null,next:[]},a=i.slice(1).reduce((function(e,t){var n=g(t,e);return e.next.push(n),n}),r),l=new Array;return s.forEach((function(e){var t={self:e,prev:null,next:[]};t.next.push(g(e,t)),l.push(t);var n={self:e,prev:a,next:[]};a.next.push(n),a=n})),[r,l]}function g(e,t){switch(e.type){case"Thread":var n={self:e.children[1],prev:t,next:[]};return e.children.slice(2).reduce((function(e,t){var n=g(t,e);return e.next.push(n),n}),n),n;case"IfStmt":var i={self:e.children[0],prev:t,next:[]},s={self:e.children[1],prev:i,next:[]},r={self:e.children[2],prev:i,next:[]};return i.next.push(s),i.next.push(r),s.self.children.reduce((function(e,t){var n=g(t,e);return e.next.push(n),n}),s),r.self.children.reduce((function(e,t){var n=g(t,e);return e.next.push(n),n}),r),i;case"VarDecl":case"AssStmt":case"LockStmt":case"Expr":case"Var":case"UnlockStmt":return{self:e,prev:t,next:[]}}throw console.log(e),new Error("Did not match!")}function y(e){var t=Object(m.a)(e,2),n=t[0],i=t[1],s=S(n,0),r=Object(m.a)(s,2),a=r[0],l=r[1];return"digraph G {\n"+a+i.reduce((function(e,t){var n=Object(m.a)(e,2),i=n[0],s=S(t,n[1]),r=Object(m.a)(s,2);return[i+r[0],r[1]+1]}),["",l+1])[0]+"\n}"}function S(e,t){for(var n="",i=new Array,s=new Array,r=function e(t,n){var r=n;if("Thread"===t.self.type?i.push("node".concat(n,' [label="Thread ').concat(t.self.children[0].text,' start" shape=plaintext]')):"Body"===t.self.type?i.push("node".concat(n,' [label="').concat(t.self.children[0].text,'" shape=plaintext]')):i.push("node".concat(n,' [label="').concat(t.self.text.trim(),'" shape=plaintext]')),"CmpExpr"===t.self.type){var a=n+1;s.push("node".concat(r," -> node").concat(a,' [label="true"]'));var l=(n=e(t.next[0],a))+1;s.push("node".concat(r," -> node").concat(l,' [label="false"]')),n=e(t.next[1],l)}else if("Body"===t.self.type){var c,o=Object(p.a)(t.next.splice(1));try{for(o.s();!(c=o.n()).done;){var d=c.value,h=n+1;d.self.type,s.push("node".concat(r," -> node").concat(h)),n=e(d,h)}}catch(j){o.e(j)}finally{o.f()}}else{var u,m=Object(p.a)(t.next);try{for(m.s();!(u=m.n()).done;){var b=u.value,f=n+1;b.self.type,s.push("node".concat(r," -> node").concat(f)),n=e(b,f)}}catch(j){m.e(j)}finally{m.f()}}return n}(e,t),a=0,l=i;a<l.length;a++){n+=l[a]+"\n"}for(var c=0,o=s;c<o.length;c++){n+=o[c]+"\n"}return[n,r]}var O="\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n";function w(e){var t=Object(s.useState)({active:!1}),n=Object(m.a)(t,2),r=n[0],a=n[1];return Object(i.jsx)("button",{className:r.active?"pure-button pure-button-primary":"pure-button pure-button-primary pure-button-active",onClick:function(){a({active:!r.active}),e.onClick()},children:e.text})}function v(){var e=y(x(j.getAST(O,"Program"))),t=Object(s.useState)(e),n=Object(m.a)(t,2),r=n[0],a=n[1],l=Object(s.useRef)(null);return Object(i.jsxs)("div",{className:"centered-limited",style:{display:"flex",flexDirection:"column"},children:[Object(i.jsxs)("div",{style:{display:"flex",flexDirection:"row"},children:[Object(i.jsx)("textarea",{ref:l,rows:20,cols:20,value:O}),Object(i.jsx)(f.a,{dot:r})]}),Object(i.jsx)(w,{text:"Render program order",onClick:function(){try{if(l.current){var e=y(x(function(e){var t;if("Thread"===(null===(t=e.children[0])||void 0===t?void 0:t.type))throw new Error("Must define at least 1 variable");if(e.children.findIndex((function(e){return"Thread"===e.type}))<0)throw new Error("Must define at least 1 thread");return e}(j.getAST(l.current.value,"Program"))));a(e)}}catch(t){}}})]})}function W(){return Object(i.jsxs)("pre",{className:"centered-limited",children:[" ",Object(i.jsx)("code",{children:'\nProgram         ::=  VarDecl*  Thread*\nThread          ::=  "thread "  Var  "{"  (IfStmt | AssStmt | LockStmt | UnlockStmt)*  "}"\nVarDecl         ::= IntDecl | VolatileIntDecl | LockDecl\nIntDecl         ::= "int"  Var " = " Expr ";"\nVolatileIntDecl ::= "volatile int"  Var " = " Expr ";"\nLockDecl        ::= "lock"  Var ";"\nIfStmt          ::=  "if"  "("  CmpExpr  ")"  "{" Body "}"  "else"  "{"  Body "}"\nBody            ::=  (IfStmt | AssStmt | LockStmt | UnlockStmt)*\nAssStmt         ::= Var " = " Expr ";"\nLockStmt        ::= Var ".lock()" ";"\nUnlockStmt      ::= Var ".unlock()" ";"\n\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr "+" Expr\nCmpExpr         ::= Expr "==" Expr | Expr ">" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\nNUMBER          ::= "-"? ("0" | [1-9] [0-9]*) ("." [0-9]+)? (("e" | "E") ( "-" | "+" )? ("0" | [1-9] [0-9]*))?\n'})," "]})}function A(e){return Object(i.jsxs)("pre",{className:"centered-limited",children:[" ",Object(i.jsxs)("code",{className:"centered-limited",children:[" ",e.children," "]})," "]})}function N(){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"center",children:"Interactive Java Memory Model"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Introduction"}),Object(i.jsxs)("p",{className:"centered-limited",children:["The Java Memory Model (JMM) is a formalism which reduces the set of possible execution traces for Java programs. This is meant to allow for users and implementers to reason about concurrent programs.",Object(i.jsx)("a",{href:"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html",children:"JLS chapter 17"})," defines the JMM. I personally did not find it very easy to grok this particular part of the spec. To solve this for me and for others I decided to implement a tool for exploring a limited form of the JMM that can run on the web. That is what this page is for :-)."]}),Object(i.jsx)("h3",{className:"centered-limited",children:"The language"}),Object(i.jsx)("p",{className:"centered-limited",children:"We will be considering a much smaller language than Java for simplicity. We will exclude loops and recursion, and we will not allow dynamically spawning threads. However we will support locks and volatile and non-volatile ints as shared memory. The abstract grammar for the language is the following."}),Object(i.jsx)(W,{}),Object(i.jsx)("h3",{className:"centered-limited",children:"Program order"}),Object(i.jsx)(v,{}),Object(i.jsx)("h3",{className:"centered-limited",children:"Inter-thread actions and synchronization actions"}),Object(i.jsxs)("p",{className:"centered-limited",children:["An ",Object(i.jsx)("i",{children:"inter-thread action"})," is something that happens that another thread can detect or influence. Consider the following program"]}),Object(i.jsx)(A,{children:"int x = 0;\n      thread A {\n        x = 1;\n      }\n      thread B {\n        if(x == 0) {\n        } else {\n  \t// We detected a change\n        }\n     }"}),Object(i.jsx)("p",{className:"centered-limited",children:"Here thread A produces a write event and thread B produces a read event. On top of regular actions there are also synchronization actions. What follows is a list of the actions we will consider, then we will consider synchronization order."}),Object(i.jsx)("h3",{className:"centered-limited",children:"Synchronization order"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Happens Before order"}),"TODO"]})}var I=n(321),k=n(320);var B=n.p+"static/media/blogpost.11d1fab8.png",T=function(e){return Object(i.jsxs)("div",{children:[Object(i.jsx)("h2",{className:"centered-limited",children:Object(i.jsx)(c.b,{to:"".concat(e.id),children:e.title})}),Object(i.jsx)("h3",{className:"centered-limited",children:e.date}),e.content]})},E=[],D=new Map,L=function(e){E.push(e),D.set(e.id,e)};L({title:"Structural subtyping",date:"2021-01-01",id:"struc-sub-type",content:Object(i.jsxs)("div",{children:[Object(i.jsx)("h3",{className:"centered-limited",children:"Introduction"}),Object(i.jsxs)("p",{className:"centered-limited",children:["Consider structural typing. Specifically, how does the type checker produce a proof that some type ",Object(i.jsx)("i",{children:"a"})," is a subtype of some other type ",Object(i.jsx)("i",{children:"b"}),"? In a nominal type system this is as easy as checking if the definition of ",Object(i.jsx)("i",{children:"a"})," mentions that it extends ",Object(i.jsx)("i",{children:"b"}),". In a structural one it becomes more complex, as we must prove that ",Object(i.jsx)("i",{children:"a"})," has the same structure as ",Object(i.jsx)("i",{children:"b"}),". This is slightly tricky when mutually recursive structures are considered. This is a fun exercise! Below is my solution in Haskell."]}),Object(i.jsx)("h3",{className:"centered-limited",children:"The language"}),Object(i.jsxs)("p",{className:"centered-limited",children:["I won't give a formal grammar, but our type language supports the following:",Object(i.jsxs)("ul",{children:[Object(i.jsxs)("li",{children:[" Unions: ",Object(i.jsx)("i",{children:"t"})," := a|b  "]}),Object(i.jsxs)("li",{children:[" Records: ",Object(i.jsx)("i",{children:"t"})," := a x b "]}),Object(i.jsxs)("li",{children:[" Primitive types: ",Object(i.jsx)("i",{children:"int"}),", ",Object(i.jsx)("i",{children:"null"})," "]})]}),"A linked list can be defined as: ",Object(i.jsx)("i",{children:"LinkedList"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LinkedList"}),"."]}),Object(i.jsx)("h3",{className:"centered-limited",children:"The solution"}),Object(i.jsxs)("p",{className:"centered-limited",children:["As most things in life all that is required is the correct perspective. We will consider types as references to vertices in a sort of directed graph or state machine. The vertices are either boxes, circles, or octagons with text in them. Circles represent unions (or primitive types), boxes records. The octagons and dashed lines are named references. To check if ",Object(i.jsx)("i",{children:"a"})," ","\u2264"," ",Object(i.jsx)("i",{children:"b"})," is equivalent to checking if a particular trace exists in both ",Object(i.jsx)("i",{children:"a"})," and ",Object(i.jsx)("i",{children:"b"}),". Consider the following types:",Object(i.jsxs)("ul",{className:"empty",children:[Object(i.jsxs)("li",{children:[" ",Object(i.jsx)("i",{children:"LinkedList"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LinkedList"})," "]}),Object(i.jsxs)("li",{children:[" ",Object(i.jsx)("i",{children:"LLInner"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LLOuter"}),"  "]}),Object(i.jsxs)("li",{children:[" ",Object(i.jsx)("i",{children:"LLOuter"})," := ",Object(i.jsx)("i",{children:"null"})," | ",Object(i.jsx)("i",{children:"int"})," x ",Object(i.jsx)("i",{children:"LLInner"}),"  "]})]}),"Is ",Object(i.jsx)("i",{children:"LinkedList"})," \u2264 ",Object(i.jsx)("i",{children:"LLInner"}),"?"]}),Object(i.jsx)("p",{className:"centered-limited",children:"To answer this question we must first compute the type graph of this instance."}),Object(i.jsx)("div",{className:"centered-limited",style:{display:"flex",flexDirection:"column"},children:Object(i.jsx)(f.a,{dot:'\ndigraph G {\n    int [label="int"];\n    null [label="null"];\n    llunion [label="", shape=circle];\n    llrecord [label="", shape=box];\n    innerunion [label="", shape=circle];\n    innerrecord [label="", shape=box];\n    outerunion [label="", shape=circle];\n    outerrecord [label="", shape=box];\n\n    LinkedList[shape=octagon]\n    LLInner[shape=octagon]\n    LLOuter[shape=octagon]\n\n    llunion -> null;\n    llunion -> llrecord;\n    llrecord -> llunion;\n    llrecord -> int;\n\n    innerunion -> null;\n    innerunion -> innerrecord;\n    innerrecord -> int;\n    innerrecord -> outerunion;\n\n    outerunion -> null;\n    outerunion -> outerrecord;\n    outerrecord -> int;\n    outerrecord -> innerunion;\n\n    LLOuter -> outerunion [style=dashed];\n    LLInner -> innerunion [style=dashed];\n    LinkedList -> llunion [style=dashed];\n}\n'})}),Object(i.jsxs)("p",{className:"centered-limited",children:["We defined this graph in Haskell utilising algebraic data types with ids for labelling unique vertices. The idea is pretty simple. Essentially for ",Object(i.jsx)("i",{children:"a"})," ","\u2264"," ",Object(i.jsx)("i",{children:"b"})," then we must be able to take lock-step identical steps in each data structure until we are in a state in both ",Object(i.jsx)("i",{children:"a"})," and ",Object(i.jsx)("i",{children:"b"})," where we've been before. Since ",Object(i.jsx)("i",{children:"b"})," must be a superset of ",Object(i.jsx)("i",{children:"a"})," we let ",Object(i.jsx)("i",{children:"a"})," decide which next step to take."]}),Object(i.jsx)(I.a,{className:"centered-limited",language:"haskell",style:k.a,children:"\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE StandaloneDeriving #-}\nimport qualified Data.Set as Set\nimport Debug.Trace\n\ndata StructuralType =\n  Union [StructuralType] Integer\n  | Record [StructuralType] Integer\n  | Int Integer\n  | Null Integer\nderiving instance Eq StructuralType\nderiving instance Ord StructuralType\n\n-- Avoid infinite recursion by not inspecting middle argument.\ninstance Show StructuralType where\n    show (Union _ id) = \"Union \" ++ (show id)\n    show (Record _ id) = \"Record \" ++ (show id)\n    show (Int id) = \"Int \" ++ (show id)\n    show (Null id) = \"Null \" ++ (show id)\n\nintt = Int 0\nnullt = Null 1\nlinkedList =\n  let node = Union [nullt, Record [intt, node] 3] 2\n  in node\ninode = Union [nullt, Record [intt, onode] 5] 4\nonode = Union [nullt, Record [intt, inode] 7] 6\ninnerList = inode\nouterList = onode\n\ntmember :: StructuralType -> Set.Set Integer -> Bool\ntmember (Record _ id) set = Set.member id set\n-- Remainder omitted for brevity\n\ntinsert :: StructuralType -> Set.Set Integer -> Set.Set Integer\ntinsert (Record _ id) set = Set.insert id set\n-- Remainder omitted for brevity\n\n-- Requires identical ordering of elements\nisSubtypeOf\n  :: StructuralType ->\n     StructuralType ->\n     Set.Set Integer ->\n     Set.Set Integer ->\n     (Bool, Set.Set Integer, Set.Set Integer)\nisSubtypeOf (Union tsA i) (Union tsB i') seenA seenB =\n  foldl ((subtype, seenA', seenB') (a,b) ->\n           if (tmember a seenA' && tmember b seenB') then (subtype, seenA', seenB') else\n             let (subtype', seenA'', seenB'') = isSubtypeOf a b seenA' seenB'\n             in (subtype' && subtype, seenA'', seenB''))\n        (True,Set.insert i seenA, Set.insert i' seenB) $ zip tsA tsB\nisSubtypeOf (Record tsA i) (Record tsB i') seenA seenB = \n  foldl ((subtype, seenA', seenB') (a,b) ->\n           if (tmember a seenA' && tmember b seenB') then (subtype, seenA', seenB') else\n             let (subtype', seenA'', seenB'') = isSubtypeOf a b seenA' seenB'\n             in (subtype' && subtype, seenA'', seenB''))\n        (True,Set.insert i seenA, Set.insert i' seenB) $ zip tsA tsB\nisSubtypeOf (Int ida) (Int idb) seenA seenB =\n  let seenA' = Set.insert ida seenA\n      seenB' = Set.insert idb seenB\n  in (True, seenA', seenB')\nisSubtypeOf (Null ida) (Null idb) seenA seenB =\n  let seenA' = Set.insert ida seenA\n      seenB' = Set.insert idb seenB\n  in (True, seenA', seenB')\nisSubtypeOf a b seenA seenB = (False, seenA, seenB)\n"}),Object(i.jsx)("h3",{className:"centered-limited",children:"Subtyping of functions"}),Object(i.jsxs)("p",{className:"centered-limited",children:["Let us expand this subtyping relation to functions. We will consider single-argument functions, in other words our types are expanded thusly:",Object(i.jsx)("ul",{children:Object(i.jsxs)("li",{children:[" (",Object(i.jsx)("i",{children:"a"})," \u2192 ",Object(i.jsx)("i",{children:"b"}),") "]})}),"And (",Object(i.jsx)("i",{children:"a"})," \u2192 ",Object(i.jsx)("i",{children:"b"}),") ","\u2264"," (",Object(i.jsxs)("i",{children:["a","'"]})," \u2192 ",Object(i.jsxs)("i",{children:["b","'"]}),") iff ",Object(i.jsxs)("i",{children:["a","'"]})," ","\u2264"," ",Object(i.jsx)("i",{children:"a"})," and ",Object(i.jsx)("i",{children:"b"})," ","\u2264"," ",Object(i.jsxs)("i",{children:["b","'"]}),". In other words a function f which is a subtype of g can accept anything that g can accept and possibly more but will return at most what g may return."]})]})}),L({title:"Here's to tagless-final encodings in Rust with GATs.",date:"2020-12-20",id:"tagless-final-gats",content:[Object(i.jsxs)("p",{className:"centered-limited",children:["Tagless-final encodings allow for embedding typed domain specific languages. Tagless-final encodings are pretty great with regards to extensibility. One term can be interpreted in multiple ways and more terms can be added to the DSL without invalidating older interpreters. These encodings are popular in at least the Haskell and Scala communities and the best source I know for learning about them in detail is ",Object(i.jsx)("a",{href:"http://okmij.org/ftp/tagless-final/index.html",children:"Oleg's website"}),"."]}),Object(i.jsx)("p",{className:"centered-limited",children:"Standard Rust already carries us half-way to tagless-final encodings, let us develop an interpreter for a toy imperative language in a tagless-final style and then see how it changes when we use GATs."}),Object(i.jsx)("h4",{className:"centered-limited",children:"In short: Initial style"}),Object(i.jsx)("p",{className:"centered-limited",children:"Writing an interpreter in an initial style is very simple. The AST of the language is described as an enum and some function taking such a structure as input interprets it to some output. If you're a beginner it might be a fun exercise to try out! Here is what the AST looks like encoded as an enum:"}),Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\npub enum While {\n    Branch(Box<While>, Box<While>, Box<While>),\n    Loop(Box<While>, Box<While>),\n    Add(Box<While>, Box<While>),\n    Gt(Box<While>, Box<While>),\n    Num(i64),\n    Bool(bool),\n    Seq(Box<While>, Box<While>),\n  Var(V),\n    Ass(String, I),\n  Skip()\n}\n"}),Object(i.jsx)("p",{className:"centered-limited",children:"Note that we could have separated this enum into two, expressions and statements, giving us further static guarantees regarding the structure of our program."}),Object(i.jsx)("h4",{className:"centered-limited",children:"In walks the GAT."}),Object(i.jsxs)("figure",{children:[Object(i.jsx)("img",{style:{display:"block"},className:"centered-limited",src:"https://www.gannett-cdn.com/-mm-/3ac9d0f81e497476b6e193a9b47176e127cdc309/c=0-33-2214-1284/local/-/media/2015/10/08/USATODAY/USATODAY/635798662187573581-NWA.jpg"}),Object(i.jsx)("figcaption",{className:"centered-limited",children:"These guys knew what a GAT was back in '87."})]}),Object(i.jsxs)("p",{className:"centered-limited",children:["Instead of expressing our programs as an enum we will model them as a trait. Any implementation of such a trait is an interpretation of it. We will implement the concrete execution interpretation of this trait, other interpretations may be a pretty-printer or a type-checker. Below is the definition of the trait for the While language.",Object(i.jsxs)("figure",{children:[Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\npub trait While {\n    type IntegerDomain;\n    type BooleanDomain;\n    type VariableDomain;\n    type UnitDomain;\n\n    type Wrapped<A>;\n\n    fn skip() -> Self::Wrapped<Self::UnitDomain>;\n    fn branch(\n        test: Self::Wrapped<Self::BooleanDomain>,\n        then_b: Self::Wrapped<Self::UnitDomain>,\n        else_b: Self::Wrapped<Self::UnitDomain>,\n    ) -> Self::Wrapped<Self::UnitDomain>;\n    fn while_loop(\n        test: Self::Wrapped<Self::BooleanDomain>,\n        body: Self::Wrapped<Self::UnitDomain>,\n    ) -> Self::Wrapped<Self::UnitDomain>;\n    fn seq(\n        x: Self::Wrapped<Self::UnitDomain>,\n        y: Self::Wrapped<Self::UnitDomain>,\n    ) -> Self::Wrapped<Self::UnitDomain>;\n    fn add(\n        x: Self::Wrapped<Self::IntegerDomain>,\n        y: Self::Wrapped<Self::IntegerDomain>,\n    ) -> Self::Wrapped<Self::IntegerDomain>;\n    fn gt(\n        x: Self::Wrapped<Self::IntegerDomain>,\n        y: Self::Wrapped<Self::IntegerDomain>,\n    ) -> Self::Wrapped<Self::BooleanDomain>;\n    fn num(x: i64) -> Self::Wrapped<Self::IntegerDomain>;\n    fn bool(x: bool) -> Self::Wrapped<Self::BooleanDomain>;\n    fn var(x: Self::VariableDomain) -> Self::Wrapped<Self::IntegerDomain>;\n    fn ass(x: String, y: Self::Wrapped<Self::IntegerDomain>) -> Self::Wrapped<Self::UnitDomain>;\n}\n"}),Object(i.jsx)("figcaption",{className:"centered-limited",children:"While as a trait with GATs in a final style."})]}),"We utilise the definition to constrain valid program configurations such that they are well-typed in our meta-language (Rust). Specifically, we now have an implicit separation between statements and expressions depending on their return type (unit meaning statement). We can see how this is enabled specifically through GATs through the Self::Wrapped type. Without GATs the equivalent would lose all of this type information and would look as such:",Object(i.jsxs)("figure",{children:[Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\npub trait While {\n\n    fn skip() -> Self;\n    fn branch(test: Self, then_b: Self, else_b: Self) -> Self;\n    fn while_loop(test: Self, body: Self) -> Self;\n    fn add(x: Self, y: Self) -> Self;\n    fn gt(x: Self, y: Self) -> Self;\n    fn num(x: i64) -> Self;\n    fn bool(x: bool) -> Self;\n    fn seq(x: Self, y: Self) -> Self;\n    fn var(x: string) -> Self;\n    fn ass(x: Self, y: Self) -> Self;\n}\n"}),Object(i.jsx)("figcaption",{className:"centered-limited",children:"While as a trait without GATs."})]}),"Indeed, this definition is almost word for word the same as the enum we first presented. Alright, so we have described our eDSL, now how do we interpret it? As with any other trait, we must implement it. The code is quite long, so I will only show some of the more interesting rules."]}),Object(i.jsxs)("p",{className:"centered-limited",children:["First we define the datatype for which the trait will be implemented. We will take the interpretation of a function taking a state as input and producing a value and new state. The state is seen as a mapping from variable names (strings) to the 64-bit integers.",Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\nstruct Eval<X>(\n    // Given a state a transition produces a value of type X and a new state\n    Box<dyn Fn(HashMap<String, i64>) -> (X, HashMap<String, i64>)>,\n);\n"}),"Let's start our implementation of the trait, specifying each associated type with their concrete equivalents.",Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\nimpl<A> While for Eval<A> {\n    type IntegerDomain = i64;\n    type BooleanDomain = bool;\n    type VariableDomain = String;\n    type UnitDomain = ();\n\n    type Unwrapped = A;\n    type Wrapped<B> = Eval<B>;\n\n"}),"Alright, ceremony over! Now for the implementation of our first reduction rules. The num and add function does not touch the state, and instead only produces a new numerical value.",Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\n    fn num(x: i64) -> Eval<i64> {\n        return Eval(Box::new(move |s| (x, s)));\n    }\n\n    fn add(a: Eval<i64>, b: Eval<i64>) -> Eval<i64> {\n        return Eval(Box::new(move |s| {\n            let x = a.0(s.clone());\n            let y = b.0(s.clone());\n            return (x.0 + y.0, s.clone());\n        }));\n    }\n"}),"var and ass both require access to the store -- one for referencing it and one for producing assignments within it.",Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:'\n    fn var(x: String) -> Eval<i64> {\n        return Eval(Box::new(move |s| match s.get(&x) {\n            Some(v) => return (v.clone(), s),\n            None => panic!("Ouch, runtime error"),\n        }));\n    }\n\n    fn ass(x: String, y: Eval<i64>) -> Eval<()> {\n        return Eval(Box::new(move |s| {\n            let v = y.0(s.clone());\n            return ((), s.update(x.clone(), v.0));\n        }));\n    }\n'}),"Branching really is why we implement our interpretation as transition functions as this allows us to only evaluate one branch at a time.",Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:"\n    fn branch(test: Eval<bool>, then_b: Eval<()>, else_b: Eval<()>) -> Eval<()> {\n        return Eval(Box::new(move |s| {\n            let x = test.0(s);\n            if x.0 == true {\n                return then_b.0(x.1);\n            } else {\n                return else_b.0(x.1);\n            }\n        }));\n    }\n}\n"}),"And here's how you use it. Unfortunately that's where our road ends, as this doesn't compile in Rust nightly yet :-(.",Object(i.jsx)(I.a,{className:"centered-limited",language:"rust",style:k.a,children:'\nfn program<W, A>() -> W\nwhere\n    W: While<Wrapped<A> = W<A>>,\n{\n    return W::branch(\n        W::gt(W::num(5), W::num(0)),\n        W::ass("result".to_string(), W::add(W::num(45), W::num(55))),\n        W::while_loop(W::bool(true), W::skip()),\n    );\n}\n\nfn main() {\n    let gs: HashMap<String, i64> = HashMap::new();\n    let y = program::<Eval<()>, ()>().0(gs);\n    println!("{:?}", y.0);\n    println!("Hello, world!");\n}\n'})]}),Object(i.jsx)("h4",{className:"centered-limited",children:"So what?"}),Object(i.jsx)("p",{className:"centered-limited",children:"Well, tagless-final style eDSLs can be quite useful. For example there could be a Rust eDSL for constraint programming, allowing for an interface similar to MiniZinc while compiling down to different solvers depending on what you need. Of course, HKT also allows for monads, which could compete in this space by means of Monadic Constraint Programming (Schrijvers, Stuckey, Wadler). For me it'd be interesting to see if these can be combined with procedural macros in some cool manner of compile-time programming. I have no idea if this is possible, this is actually my first Rust program :-). Oleg's website has a  lot of examples of when tagless-final is useful and it's a very Google-able term, check it out!"}),Object(i.jsxs)("p",{className:"centered-limited",children:["There are ",Object(i.jsx)("a",{href:"https://degoes.net/articles/tagless-horror",children:"reasonable objections"})," to how tagless-final is used in the Scala community, especially with regards to effect management. I can't predict the future, and I'm not some sort of Rust influencer, so I'm not going to pretend like tagless-final is an obvious hit for the Rust community. But hey, at least it made for a neat blog post."]})]}),L({title:"How I run this site.",date:"2020-12-18",id:"how-i-run-this-site",content:[Object(i.jsx)("p",{className:"centered-limited",children:"This is the KISS version of running a personal site. I got my css from pure-css and I run everything as a React app using gh-pages and react-scripts. Every blog post is a small program which pushes a post onto an array which is then rendered by a function (I use React Hooks). I treat the entire website as a program where I run whatever I want. There are essentially no static assets. I can whole-heartedly recommend this as a no-frills version of writing and hosting a personal site."}),Object(i.jsx)("p",{className:"centered-limited",children:"Unfortunately the site takes an absurd amount of memory. Loading the site can take a while, according to Firefox almost 2MB of compressed JavaScript is sent over the wire. I assume that the majority of this is the libraries which I import."}),Object(i.jsx)("img",{style:{display:"block"},className:"centered-limited",src:B,alt:"How I wrote this blog post"})]});var U=function(){var e=Object(o.f)().id;if("all"===e)return Object(i.jsxs)("div",{children:[Object(i.jsx)("h1",{className:"center",children:"Blog"}),E.map(T)]});var t=D.get(e);return t?Object(i.jsx)("div",{children:T(t)}):Object(i.jsx)("div",{children:Object(i.jsx)("h1",{className:"center",children:"Blog post not found."})})};var V=function(){return Object(s.useEffect)((function(){document.title="A page."})),Object(i.jsxs)(c.a,{children:[Object(i.jsxs)("ul",{className:"pure-menu-horizontal",children:[Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(c.b,{className:"pure-menu-link",to:"/",children:"Home"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(c.b,{className:"pure-menu-link",to:"/blog/all",children:"Blog"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(c.b,{className:"pure-menu-link",to:"/relsymwasm",children:"MSc thesis"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(c.b,{className:"pure-menu-link",to:"/bsc",children:"BSc thesis"})}),Object(i.jsx)("li",{className:"pure-menu-item",children:Object(i.jsx)(c.b,{className:"pure-menu-link",to:"/jmm",children:"JMM (WIP)"})})]}),Object(i.jsxs)(o.c,{children:[Object(i.jsx)(o.a,{exact:!0,path:"/relsymwasm",component:d}),Object(i.jsx)(o.a,{exact:!0,path:"/blog/:id",component:U}),Object(i.jsx)(o.a,{exact:!0,path:"/bsc",component:h}),Object(i.jsx)(o.a,{exact:!0,path:"/jmm",component:N}),Object(i.jsx)(o.a,{exact:!0,path:"/",component:u})]})]})};n(313);l.a.render(Object(i.jsx)(r.a.StrictMode,{children:Object(i.jsx)(V,{})}),document.getElementById("root"))},60:function(e,t,n){},71:function(e,t){},72:function(e,t){}},[[315,1,2]]]);
//# sourceMappingURL=main.c50043a3.chunk.js.map