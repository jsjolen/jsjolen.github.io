{"version":3,"sources":["RelSymWasm.tsx","BSc.tsx","Home.tsx","JMM.tsx","StructuralTyping.tsx","blogpost.png","Blog.tsx","App.tsx","index.tsx"],"names":["RelSymWasm","className","href","BSc","Home","style","margin","parser","Grammars","W3C","Parser","computeProgramOrder","node","children","reduce","token","varDecls","threadDecls","type","push","Error","mainThread","self","prev","next","mainThreadControlPoint","slice","_computeProgramOrder","threadComponents","Array","forEach","thread","threadNode","startThreadVertex","Stmt","cmpNode","thenNode","elseNode","console","log","programOrderToDot","mainThreadComponent","programOrderComponentToDot","main","nextIdx","vertex","out","start","startingIdx","output","vertices","edges","nodeIdx","writer","vidx","text","trim","thenBranch","elseBranch","splice","child","cid","initProgram","Button","props","useState","active","state","setState","onClick","ProgramOrderInput","initGraph","getAST","lastRender","setLastRender","textAreaRef","useRef","display","flexDirection","ref","rows","cols","value","Graphviz","dot","current","graph","program","findIndex","v","semanticAnalysis","e","Grammar","Program","JMM","StructuralTyping","language","docco","post","Post","to","id","title","date","content","posts","idToPost","Map","src","BlogPostImage","alt","set","Blog","useParams","reverse","map","get","App","useEffect","document","exact","path","component","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.fc263271.chunk.js","sourcesContent":["import React from 'react'\n\nexport function RelSymWasm() {\n  return (\n    <div>\n      <h2 className=\"center\">Relational Symbolic Execution in WebAssembly</h2>\n      <h3 className=\"centered-limited\">Abstract</h3>\n      <p className=\"centered-limited\">\n      WebAssembly is a new low-level language used as a compilation target which runs in web browsers. As more code is run on the client side of a web application the issue of security of that code become more important. Our work is based in the approach of using formal verification in order to prove that for a program one or more security properties hold. In this thesis we have explored the usage of relational symbolic execution in order to perform formal verification of security properties for WebAssembly programs. We described a formal semantics of relational symbolic execution for WebAssembly, implemented it in the Redex framework, extended the implementation for verification of constant-time security, and used the implementation to formally verify multiple sample programs including Salsa20. Our work shows that relational verification of standard security properties such as non-interference and constant-time security by using relational symbolic execution for WebAssembly is a viable approach.\n      </p>\n      <a className=\"center\" href=\"https://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A1471675&dswid=4728\">Available from DiVA here</a>\n      <a className=\"center\" href=\"https://github.com/jsjolen/relsym-wasm\">Source code available here</a>\n      </div>\n  );\n}\n","import React from 'react'\n\nexport function BSc() {\n  return (\n    <div>\n      <h2 className=\"center\">Probabilistic Least-violating Control Strategy Synthesis with Safety Rules</h2>\n      <h3 className=\"centered-limited\">Abstract</h3>\n      <p className=\"centered-limited\">\nWe consider the problem of automatic control strategy synthesis for discrete models of robotic systems, where the goal is to travel from some region to another while obeying a given set of safety rules in an environment with uncertain properties. This is a probabilistic extension of the work by Jana Tumová et al.  that is able to handle uncertainty by modifying the least-violating strategy synthesis algorithm. The first novel contribution is a way of modelling uncertain events in a map as a Markov decision process with a specific structure, using what we call \"Ghost States\". We then introduce a way of constructing a Product Automaton analogous to the original work, on which a modified probabilistic version of Dijkstra's algorithm can be run to synthesize the least-violating plan. The result is a synthesis algorithm that works similarly to the original, but can handle probabilistic uncertainty. It could be used in cases where e.g. uncertain weather conditions or the behaviour of external actors can be modelled as stochastic variables.\n      </p>\n      <a className=\"center\" href=\"https://kth.diva-portal.org/smash/record.jsf?dswid=-5756&pid=diva2%3A1215050\">Available from DiVA here</a>\n      </div>\n  );\n}\n","import React from 'react';\nimport './pure.css';\n\nexport function Home() {\n  return (\n    <div>\n      <header>\n      <h1 style={{margin:\"2em\"}}>Johan Sjölén</h1>\n      </header>\n      <h3 className=\"centered-limited\">Welcome </h3>\n      <p className=\"centered-limited\">\n      I'm a software engineer with a MSc from KTH Royal Institute of Technology (also civilingenjör for any Swede out there).\n      I have a wide array of interests including but not limited to the following.</p>\n      <ul className=\"centered-limited\">\n        <li>Compilers and PL theory</li>\n        <li>Formal methods</li>\n        <li>Security</li>\n        <li>Distributed systems</li>\n        <li>Functional programming</li>\n      </ul>\n      <p className=\"centered-limited\">\n      On this page you will find any work I've done pertaining to these topics.\n      You may contact me at: johan.borglin.sjolen at gmail dot com.\n      </p>\n    </div>\n  );\n}\n","import React, { useState, FunctionComponent, ReactNode, useRef } from 'react';\nimport { Grammars, IToken } from 'ebnf';\nimport { Graphviz } from 'graphviz-react';\n\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\n// TODO:\n// Add special rendering for Thread where edge is dotted in PO\n// Add special rendering for CmpExpr where edges denote true/false\n\nconst TLangGrammar =\n`\nProgram         ::= WS* VarDecl* WS* Thread* WS*\nThread          ::= WS* \"thread \" WS* Var WS* \"{\" WS* (IfStmt | AssStmt | LockStmt | UnlockStmt)* WS* \"}\" WS*\nVarDecl         ::= IntDecl | VolatileIntDecl | LockDecl\nIntDecl         ::= \"int\" WS* Var \" = \" Expr \";\" WS*\nVolatileIntDecl ::= \"volatile int\" WS* Var \" = \" Expr \";\" WS*\nLockDecl        ::= \"lock\" WS* Var \";\" WS*\nIfStmt          ::= WS* \"if\" WS* \"(\" WS* CmpExpr WS* \")\" WS* \"{\" Body \"}\" WS* \"else\" WS* \"{\" WS* Body \"}\" WS*\nBody            ::= WS* (IfStmt | AssStmt | LockStmt | UnlockStmt)* WS*\nAssStmt         ::= Var \" = \" Expr \";\" WS*\nLockStmt        ::= Var \".lock()\" \";\" WS*\nUnlockStmt      ::= Var \".unlock()\" \";\" WS*\n\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr \"+\" Expr\nCmpExpr         ::= Expr \"==\" Expr | Expr \">\" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\nNUMBER          ::= \"-\"? (\"0\" | [1-9] [0-9]*) (\".\" [0-9]+)? ((\"e\" | \"E\") ( \"-\" | \"+\" )? (\"0\" | [1-9] [0-9]*))?\nWS              ::= [#x20#x09#x0A#x0D]+\n`;\n\nconst presentableGrammar =\n`\nProgram         ::=  VarDecl*  Thread*\nThread          ::=  \"thread \"  Var  \"{\"  (IfStmt | AssStmt | LockStmt | UnlockStmt)*  \"}\"\nVarDecl         ::= IntDecl | VolatileIntDecl | LockDecl\nIntDecl         ::= \"int\"  Var \" = \" Expr \";\"\nVolatileIntDecl ::= \"volatile int\"  Var \" = \" Expr \";\"\nLockDecl        ::= \"lock\"  Var \";\"\nIfStmt          ::=  \"if\"  \"(\"  CmpExpr  \")\"  \"{\" Body \"}\"  \"else\"  \"{\"  Body \"}\"\nBody            ::=  (IfStmt | AssStmt | LockStmt | UnlockStmt)*\nAssStmt         ::= Var \" = \" Expr \";\"\nLockStmt        ::= Var \".lock()\" \";\"\nUnlockStmt      ::= Var \".unlock()\" \";\"\n\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr \"+\" Expr\nCmpExpr         ::= Expr \"==\" Expr | Expr \">\" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\nNUMBER          ::= \"-\"? (\"0\" | [1-9] [0-9]*) (\".\" [0-9]+)? ((\"e\" | \"E\") ( \"-\" | \"+\" )? (\"0\" | [1-9] [0-9]*))?\n`;\n\ntype TLangAstType =\n  'Program' |\n  'Thread' |\n  'VarDecl' |\n  //'Stmt' |\n  'IfStmt' |\n  'AssStmt' |\n  'LockStmt' |\n  'UnlockStmt' |\n  'Expr' |\n  'AddExpr' |\n  'CmpExpr' |\n  'Var' |\n  'Value';\n/*\nGrammar tests.\n*/\nconst parser = new Grammars.W3C.Parser(TLangGrammar);\n/*\nconsole.log(parser.getAST(\"5\", \"Value\"));\nconsole.log(parser.getAST(\"x\", \"Var\"));\nconsole.log(parser.getAST(\"volatile int x = 5;\", \"VarDecl\"));\nconsole.log(parser.getAST(`\nthread A {\n    x = 5;\n    y = 6;\n}\n`, \"Thread\"));\nconsole.log(parser.getAST(`\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n`, \"IfStmt\"))\nconsole.log(parser.getAST(`\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`,\"Program\"));\n*/\n\n/*\n  Semantic analysis\n  */\n\nfunction semanticAnalysis(program : IToken) : IToken {\n  if(program.children[0]?.type === 'Thread') {\n    throw new Error('Must define at least 1 variable');\n  }\n  const tidx = program.children.findIndex((v) => {\n    return v.type === 'Thread';\n  });\n  if(tidx < 0) {\n    throw new Error('Must define at least 1 thread');\n  }\n  return program;\n}\n\ntype TypeEnv = Map<string, TypeInfo>;\ninterface TypeInfo {\n  isVolatile: boolean;\n  type: 'int'|'lock';\n}\n\n\n/*\nIntDecl         ::= \"int\" WS* Var \" = \" Expr \";\" WS*\nVolatileIntDecl ::= \"volatile int\" WS* Var \" = \" Expr \";\" WS*\nLockDecl        ::= \"lock\" WS* Var \";\" WS*\n */\nfunction typeEnv(program: IToken): TypeEnv {\n  if(program.type !== 'Program') {\n    throw new Error('Can only find environment of whole program');\n  }\n  const varDecls = program.children.reduce<Array<IToken>>((varDecls, token)  => {\n    switch(token.type) {\n      case 'VarDecl': {\n\tvarDecls.push(token);\n\treturn varDecls;\n      }\n      default: {\n\treturn varDecls;\n      }\n    }\n  }, []);\n\n  const m = new Map<string, TypeInfo>();\n  for(const varDecl of varDecls) {\n    const decl = varDecl.children[0];\n    console.log(decl);\n    switch(decl.type) {\n      case 'IntDecl': {\n\tm.set(decl.children[0].text, {isVolatile:false, type:'int'});\n\tbreak;\n      }\n      case 'VolatileIntDecl': {\n\tm.set(decl.children[0].text, {isVolatile:true, type:'int'});\n\tbreak;\n      }\n      case 'LockDecl': {\n\tm.set(decl.children[0].text, {isVolatile:true, type:'lock'});\n\tbreak;\n      }\n    }\n  }\n  return m;\n}\n\n/*\n  Program order.\n*/\n\ninterface POVertex {\n  self: IToken;\n  prev: POVertex|null;\n  next: Array<POVertex>;\n}\n\ninterface TLangToken extends IToken {\n  type: TLangAstType;\n}\n\n/*\n  cpo and _cpo depends a lot on mutable binding of next.\n  I think in Haskell we solve this by lazy evaluation for filling out that list.\n */\n\nfunction computeProgramOrder(node: IToken): [POVertex, Array<POVertex>] {\n  const [varDecls, threadDecls] = node.children.reduce<[Array<IToken>,Array<IToken>]>(([varDecls, threadDecls], token)  => {\n    switch(token.type) {\n      case 'VarDecl': {\n\tvarDecls.push(token);\n\treturn [varDecls, threadDecls];\n      }\n      case 'Thread': {\n\tthreadDecls.push(token);\n\treturn [varDecls, threadDecls];\n      }\n      default: {\n        throw new Error('no way!');\n      }\n    }\n  }, [[],[]]);\n\n  const mainThread = {self:varDecls[0], prev:null, next:[]};\n  let mainThreadControlPoint = varDecls.slice(1).reduce<POVertex>((prev, token) => {\n    const next = _computeProgramOrder(token, prev);\n    prev.next.push(next);\n    return next;\n  }, mainThread);\n  // Attach to each threadDecl\n  const threadComponents : POVertex[] = new Array();\n  threadDecls.forEach((thread) => {\n    const threadNode : POVertex = {self: thread, prev: null, next: []};\n    threadNode.next.push(_computeProgramOrder(thread, threadNode));\n    threadComponents.push(threadNode);\n\n    const startThreadVertex : POVertex = {self: thread, prev: mainThreadControlPoint, next: []};\n    mainThreadControlPoint.next.push(startThreadVertex);\n    mainThreadControlPoint = startThreadVertex;\n  });\n  return [mainThread, threadComponents]; // return start\n}\n\nfunction _computeProgramOrder(node: IToken, prev: POVertex): POVertex {\n  switch(node.type) {\n    case 'Thread': {\n      // const thread = {self: node, prev, next: []};\n      const Stmt = {self: node.children[1], prev, next: []};\n      // .slice(1) ignore name\n      node.children.slice(2).reduce<POVertex>((prev, token) => {\n        const next = _computeProgramOrder(token, prev);\n        prev.next.push(next);\n        return next;\n      }, Stmt);\n      return Stmt;\n    }\n    case 'IfStmt': {\n      const cmpNode : POVertex = {self: node.children[0], prev, next: []},\n            thenNode : POVertex = {self: node.children[1], prev: cmpNode, next: []},\n            elseNode : POVertex = {self: node.children[2], prev: cmpNode, next: []};\n      cmpNode.next.push(thenNode);\n      cmpNode.next.push(elseNode);\n      (thenNode.self as IToken).children.reduce<POVertex>((prev, token) => {\n        const next = _computeProgramOrder(token, prev);\n        prev.next.push(next);\n        return next;\n      }, thenNode);\n      (elseNode.self as IToken).children.reduce<POVertex>((prev, token) => {\n        const next = _computeProgramOrder(token, prev);\n        prev.next.push(next);\n        return next;\n      }, elseNode);\n      return cmpNode;\n    }\n      //case 'Stmt':\n    case 'VarDecl':\n    case 'AssStmt':\n    case 'LockStmt':\n    case 'Expr':\n    case 'Var':\n    case 'UnlockStmt':\n      return {self: node, prev, next: []};\n  }\n  console.log(node);\n  throw new Error('Did not match!');\n}\n/*\nProgram order tests.\n*/\n/*\nconsole.log(computeProgramOrder(parser.getAST(\"volatile int x = 5;\", \"VarDecl\"), {self: 'START', prev: null, next: []}));\nconsole.log(computeProgramOrder(parser.getAST(`\nthread A {\n    x = 5;\n    y = 6;\n}\n`, \"Thread\"), {self: 'START', prev: null, next: []}));\n\nconsole.log(computeProgramOrder(parser.getAST(`\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`,\"Program\"), {self: 'START', prev: null, next: []}));\nconsole.log(computeProgramOrder(parser.getAST(`\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`,\"Program\"), {self: 'START', prev: null, next: []}));\n*/\n/*\nconsole.log(computeProgramOrder(parser.getAST(`\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n        y = 0;\n    }\n    else {\n       y = 2;\n       y = 0;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`,\"Program\")));\n*/\n/*\n  Render program order.\n*/\n\nfunction programOrderToDot([mainThreadComponent, threadComponents] : [POVertex, Array<POVertex>]): string {\n  let output = 'digraph G {\\n';\n  const [main, nextIdx] = programOrderComponentToDot(mainThreadComponent, 0);\n  const threads = threadComponents.reduce<[string, number]>(\n    ([out, nextIdx]: [string, number], vertex: POVertex): [string, number] => {\n      const [foo, bar] = programOrderComponentToDot(vertex, nextIdx)\n      return [out+foo, bar+1];\n    }, ['', nextIdx+1])[0];\n  return (\n    output +\n    main +\n    threads +\n    '\\n}'\n  );\n}\n\nfunction programOrderComponentToDot(start: POVertex, startingIdx: number): [string, number] {\n  let output = '';\n  // No loops, we can just push\n  const vertices = new Array<string>(),\n        edges = new Array<string>();\n  const writer = (node: POVertex, nodeIdx:number) => {\n    let vidx = nodeIdx;\n    // Add self-vertex if applicable\n    if(node.self.type === 'Thread') {\n      vertices.push(`node${nodeIdx} [label=\"Thread ${node.self.children[0].text} start\" shape=plaintext]`);\n    } else if(node.self.type === 'Body') {\n      // Add first stmt in body\n      vertices.push(`node${nodeIdx} [label=\"${node.self.children[0].text}\" shape=plaintext]`);\n    } else {\n      vertices.push(`node${nodeIdx} [label=\"${(node.self as IToken).text.trim()}\" shape=plaintext]`);\n    }\n    // Add child edges, etc.\n    if(node.self.type === 'CmpExpr') {\n      const thenBranch = nodeIdx+1;\n      edges.push(`node${vidx} -> node${thenBranch} [label=\"true\"]`);\n      nodeIdx = writer(node.next[0], thenBranch);\n      const elseBranch = nodeIdx+1;\n      edges.push(`node${vidx} -> node${elseBranch} [label=\"false\"]`);\n      nodeIdx = writer(node.next[1], elseBranch);\n    } else if(node.self.type === 'Body') {\n      // Skip first child\n      for(const child of node.next.splice(1)) {\n\tconst cid = nodeIdx+1;\n\tif(child.self.type === 'Thread') {\n\t  edges.push(`node${vidx} -> node${cid}`);\n\t} else {\n\t  edges.push(`node${vidx} -> node${cid}`);\n\t}\n\tnodeIdx = writer(child, cid);\n      }\n    }\n    else {\n      for(const child of node.next) {\n\tconst cid = nodeIdx+1;\n\tif(child.self.type === 'Thread') {\n\t  edges.push(`node${vidx} -> node${cid}`);\n\t} else {\n\t  edges.push(`node${vidx} -> node${cid}`);\n\t}\n\tnodeIdx = writer(child, cid);\n      }\n    }\n    return nodeIdx;\n  }\n  const nodeIdx = writer(start, startingIdx);\n  for(const vertex of vertices) {\n    output += vertex+\"\\n\";\n  }\n  for(const edge of edges) {\n    output += edge+\"\\n\";\n  }\n  return [output, nodeIdx];\n}\n\n/**\n   Test programOrderToDot\n**/\n/*\nconsole.log(programOrderToDot(computeProgramOrder(parser.getAST(`\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n        y = 0;\n}\n    else {\n       y = 2;\ny = 0;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`,\"Program\"))));\n\nconsole.log(computeProgramOrder(parser.getAST(`\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`,\"Program\")));\n*/\n/*\n  PO gui\n*/\nconst initProgram = `\nvolatile int x = 5;\nint y = 6;\nthread A {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\nthread B {\n    y = 5;\n    if (x>5) {\n        y = 3;\n    }\n    else {\n       y = 2;\n    }\n}\n`;\n\nfunction Button(props: {text:string, onClick: () => void|Promise<void>}) {\n  const [state, setState] = useState({active:false});\n  return (\n    <button className={state.active ? \"pure-button pure-button-primary\" : \"pure-button pure-button-primary pure-button-active\"}\n    onClick={() => {\n      setState({active: !state.active});\n      props.onClick();\n    }}>{props.text}</button>\n  );\n}\n\nfunction ProgramOrderInput() {\n  const initGraph = programOrderToDot(computeProgramOrder(parser.getAST(initProgram,'Program')));\n  const [lastRender, setLastRender] = useState(initGraph);\n  const textAreaRef  = useRef<HTMLTextAreaElement>(null);\n  return (\n    <div className=\"centered-limited\" style={{display: \"flex\", flexDirection:\"column\"}}>\n      <div style={{display: \"flex\", flexDirection:\"row\"}}>\n        <textarea ref={textAreaRef} rows={20} cols={20} value={initProgram}/>\n        <Graphviz dot={lastRender}/>\n      </div>\n      <Button text=\"Render program order\"\n              onClick={() => {\n\t\ttry {\n\t\t  if(textAreaRef.current) {\n\t\t    const graph = programOrderToDot(computeProgramOrder(semanticAnalysis(parser.getAST(textAreaRef.current.value,'Program'))));\n\t\t    setLastRender(graph);\n\t\t  }\n\t\t} catch(e) {\n\t\t}\n\t      }}/>\n    </div>\n  );\n}\n\n/*\n  Synchronization Actions.\n  Requires recurring inside of Exprs to find writes/reads.\n*/\n\ninterface SynchAction {\n  origin: IToken;\n  info: SynchActionInfo;\n}\ninterface SynchActionInfo {\n  actionType: 'volread'|'volwrite'|'lock'|'unlock';\n}\n\nfunction parseSynchAction(node: IToken, env: TypeEnv): Set<SynchAction> {\n  switch(node.type) {\n    case 'LockStmt': {\n      const x : SynchAction = {origin: node, info: { actionType: 'lock' }};\n      return new Set([x]);\n    }\n    case 'UnlockStmt': {\n      const x : SynchAction = {origin: node, info: { actionType: 'unlock' }};\n      return new Set([x]);\n    }\n    case 'AssStmt': {\n      const assignInfo = env.get(node.children[0].text);\n      const sas: Set<SynchAction> = parseSynchActionExpr(node.children[1].children[0], env);;\n      if(assignInfo && assignInfo.isVolatile) {\n\tsas.add({origin: node, info: { actionType: 'volwrite' }});\n      }\n      return sas;\n    }\n  }\n  throw new Error('unreachable');\n}\n\n/**\nExpr            ::= Var | Value | CmpExpr | AddExpr\nAddExpr         ::= Expr \"+\" Expr\nCmpExpr         ::= Expr \"==\" Expr | Expr \">\" Expr\nVar             ::= ([a-z]|[A-Z])+\nValue           ::= NUMBER\n\n**/\nfunction union<T>(a: Set<T>, b: Set<T>): Set<T> {\n  a.forEach((x) => {\n    b.add(x);\n  });\n  return b;\n}\n\nfunction parseSynchActionExpr(node: IToken, env: TypeEnv): Set<SynchAction> {\n  switch(node.type) {\n      case 'Var': {\n\tif(env.get(node.text)?.isVolatile) {\n\t  const x : SynchAction = {origin: node,info: {actionType: 'volread'}};\n\t  return new Set([x]);\n\t} else {\n\t  return new Set();\n\t}\n      }\n    case 'CmpExpr':\n    case 'AddExpr': {\n      return union(parseSynchActionExpr(node.children[0], env),\n\t\t   parseSynchActionExpr(node.children[1], env));\n    }\n    case 'Value': {\n      return new Set();\n    }\n  }\n  throw new Error('Unreachable');\n}\n\nfunction synchronizationOrder(program: IToken): Array<SynchAction> {\n  return [];\n}\n\n/*\n  Rendering.\n*/\n\nexport function Grammar() {\n  return <pre className=\"centered-limited\"> <code>{presentableGrammar}</code> </pre>;\n}\n\nfunction Program(props: {children: ReactNode}) {\n  return <pre className=\"centered-limited\"> <code className=\"centered-limited\"> {props.children} </code> </pre>;\n}\n\nexport function JMM() {\n  return (\n    <div>\n    <h2 className=\"center\">Interactive Java Memory Model</h2>\n    <h3 className=\"centered-limited\">Introduction</h3>\n    <p className=\"centered-limited\">\n      The Java Memory Model (JMM) is a formalism which reduces the set of possible execution traces for Java programs.\n      This is meant to allow for users and implementers to reason about concurrent programs.\n      <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html\">JLS chapter 17</a> defines the JMM.\n      I personally did not find it very easy to grok this particular part of the spec.\n      To solve this for me and for others I decided to implement a tool for exploring a limited form of the JMM\n      that can run on the web. That is what this page is for :-).\n      </p>\n     <h3 className=\"centered-limited\">The language</h3>\n     <p className=\"centered-limited\">\n     We will be considering a much smaller language than Java for simplicity.\n     We will exclude loops and recursion, and we will not allow dynamically spawning threads.\n     However we will support locks and volatile and non-volatile ints as shared memory.\n     The abstract grammar for the language is the following.\n     </p>\n     <Grammar/>\n    <h3 className=\"centered-limited\">Program order</h3>\n    <ProgramOrderInput/>\n    <h3 className=\"centered-limited\">Inter-thread actions and synchronization actions</h3>\n    <p className=\"centered-limited\">\n    An <i>inter-thread action</i> is something that happens that another thread can detect or influence.\n    Consider the following program\n    </p>\n    <Program>\n    {`int x = 0;\n      thread A {\n        x = 1;\n      }\n      thread B {\n        if(x == 0) {\n        } else {\n  \t// We detected a change\n        }\n     }`}\n  </Program>\n    <p className=\"centered-limited\">\n    Here thread A produces a write event and thread B produces a read event.\n    On top of regular actions there are also synchronization actions.\n    What follows is a list of the actions we will consider, then we will consider synchronization order.\n    </p>\n    <h3 className=\"centered-limited\">Synchronization order</h3>\n    <h3 className=\"centered-limited\">Happens Before order</h3>\n    TODO\n     </div>\n  );\n}\n","import React from 'react'\nimport { Graphviz } from 'graphviz-react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nconst Component = () => {\n  const codeString = '(num) => num + 1';\n  return (\n    <SyntaxHighlighter language=\"javascript\" style={docco}>\n      {codeString}\n    </SyntaxHighlighter>\n  );\n};\n\nconst typeGraph = `\ndigraph G {\n    int [label=\"int\"];\n    null [label=\"null\"];\n    llunion [label=\"\", shape=circle];\n    llrecord [label=\"\", shape=box];\n    innerunion [label=\"\", shape=circle];\n    innerrecord [label=\"\", shape=box];\n    outerunion [label=\"\", shape=circle];\n    outerrecord [label=\"\", shape=box];\n\n    LinkedList[shape=octagon]\n    LLInner[shape=octagon]\n    LLOuter[shape=octagon]\n\n    llunion -> null;\n    llunion -> llrecord;\n    llrecord -> llunion;\n    llrecord -> int;\n\n    innerunion -> null;\n    innerunion -> innerrecord;\n    innerrecord -> int;\n    innerrecord -> outerunion;\n\n    outerunion -> null;\n    outerunion -> outerrecord;\n    outerrecord -> int;\n    outerrecord -> innerunion;\n\n    LLOuter -> outerunion [style=dashed];\n    LLInner -> innerunion [style=dashed];\n    LinkedList -> llunion [style=dashed];\n}\n`;\n\nconst hsCode = `\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE StandaloneDeriving #-}\nimport qualified Data.Set as Set\nimport Debug.Trace\n\ndata StructuralType =\n  Union [StructuralType] Integer\n  | Record [StructuralType] Integer\n  | Int Integer\n  | Null Integer\nderiving instance Eq StructuralType\nderiving instance Ord StructuralType\n\n-- Avoid infinite recursion by not inspecting middle argument.\ninstance Show StructuralType where\n    show (Union _ id) = \"Union \" ++ (show id)\n    show (Record _ id) = \"Record \" ++ (show id)\n    show (Int id) = \"Int \" ++ (show id)\n    show (Null id) = \"Null \" ++ (show id)\n\nintt = Int 0\nnullt = Null 1\nlinkedList =\n  let node = Union [nullt, Record [intt, node] 3] 2\n  in node\ninode = Union [nullt, Record [intt, onode] 5] 4\nonode = Union [nullt, Record [intt, inode] 7] 6\ninnerList = inode\nouterList = onode\n\ntmember :: StructuralType -> Set.Set Integer -> Bool\ntmember (Record _ id) set = Set.member id set\n-- Remainder omitted for brevity\n\ntinsert :: StructuralType -> Set.Set Integer -> Set.Set Integer\ntinsert (Record _ id) set = Set.insert id set\n-- Remainder omitted for brevity\n\n-- Requires identical ordering of elements\nisSubtypeOf\n  :: StructuralType ->\n     StructuralType ->\n     Set.Set Integer ->\n     Set.Set Integer ->\n     (Bool, Set.Set Integer, Set.Set Integer)\nisSubtypeOf (Union tsA i) (Union tsB i') seenA seenB =\n  foldl (\\(subtype, seenA', seenB') (a,b) ->\n           if (tmember a seenA' && tmember b seenB') then (subtype, seenA', seenB') else\n             let (subtype', seenA'', seenB'') = isSubtypeOf a b seenA' seenB'\n             in (subtype' && subtype, seenA'', seenB''))\n        (True,Set.insert i seenA, Set.insert i' seenB) $ zip tsA tsB\nisSubtypeOf (Record tsA i) (Record tsB i') seenA seenB = \n  foldl (\\(subtype, seenA', seenB') (a,b) ->\n           if (tmember a seenA' && tmember b seenB') then (subtype, seenA', seenB') else\n             let (subtype', seenA'', seenB'') = isSubtypeOf a b seenA' seenB'\n             in (subtype' && subtype, seenA'', seenB''))\n        (True,Set.insert i seenA, Set.insert i' seenB) $ zip tsA tsB\nisSubtypeOf (Int ida) (Int idb) seenA seenB =\n  let seenA' = Set.insert ida seenA\n      seenB' = Set.insert idb seenB\n  in (True, seenA', seenB')\nisSubtypeOf (Null ida) (Null idb) seenA seenB =\n  let seenA' = Set.insert ida seenA\n      seenB' = Set.insert idb seenB\n  in (True, seenA', seenB')\nisSubtypeOf a b seenA seenB = (False, seenA, seenB)\n`;\n\nexport function StructuralTyping() {\n  return (\n    <div>\n      <h2 className=\"center\">Structural subtyping</h2>\n      <h3 className=\"centered-limited\">Introduction</h3>\n      <p className=\"centered-limited\">\n      Consider structural typing. Specifically, how does the type checker produce a proof that some type <i>a</i> is a subtype of some other type <i>b</i>?\n      In a nominal type system this is as easy as checking if the definition of <i>a</i> mentions that it extends <i>b</i>.\n      In a structural one it becomes more complex, as we must prove that <i>a</i> has the same structure as <i>b</i>.\n      This is slightly tricky when mutually recursive structures are considered.\n      This is a fun exercise! Below is my solution in Haskell.\n      </p>\n\n      <h3 className=\"centered-limited\">The language</h3>\n      <p className=\"centered-limited\">\n      I won't give a formal grammar, but our type language supports the following:\n      <ul>\n      <li> Unions: <i>t</i> := a|b  </li>\n      <li> Records: <i>t</i> := a x b </li>\n      <li> Primitive types: <i>int</i>, <i>null</i> </li>\n      </ul>\n      A linked list can be defined as: <i>LinkedList</i> := <i>null</i> | <i>int</i> x <i>LinkedList</i>.\n      </p>\n\n      <h3 className=\"centered-limited\">The solution</h3>\n      <p className=\"centered-limited\">\n      As most things in life all that is required is the correct perspective.\n      We will consider types as references to vertices in a sort of directed graph or state machine.\n      The vertices are either boxes, circles, or octagons with text in them. Circles represent unions (or primitive types), boxes records. The octagons and dashed lines are named references.\n      To check if <i>a</i> {\"≤\"} <i>b</i> is equivalent to checking if a particular trace exists in both <i>a</i> and <i>b</i>.\n      Consider the following types:\n      <ul className=\"empty\">\n      <li> <i>LinkedList</i> := <i>null</i> | <i>int</i> x <i>LinkedList</i> </li>\n      <li> <i>LLInner</i> := <i>null</i> | <i>int</i> x <i>LLOuter</i>  </li>\n      <li> <i>LLOuter</i> := <i>null</i> | <i>int</i> x <i>LLInner</i>  </li>\n      </ul>\n      Is <i>LinkedList</i> ≤ <i>LLInner</i>?\n      </p>\n      <p className=\"centered-limited\">\n      To answer this question we must first compute the type graph of this instance.\n      </p>\n      <div className=\"centered-limited\" style={{display: \"flex\", flexDirection:\"column\"}}>\n      <Graphviz dot={typeGraph}/>\n      </div>\n      <p className=\"centered-limited\">\n      We defined this graph in Haskell utilising algebraic data types with ids for labelling unique vertices.\n      The idea is pretty simple. Essentially for <i>a</i> {\"≤\"} <i>b</i> then we must be able to take lock-step identical steps in each data structure until we are in a state in both <i>a</i> and <i>b</i> where we've been before.\n      Since <i>b</i> must be a superset of <i>a</i> we let <i>a</i> decide which next step to take.\n      </p>\n      <SyntaxHighlighter className=\"centered-limited\" language=\"haskell\" style={docco}>\n       {hsCode}\n      </SyntaxHighlighter>\n      <h3 className=\"centered-limited\">Subtyping of functions</h3>\n      <p className=\"centered-limited\">\n      Let us expand this subtyping relation to functions.\n      We will consider single-argument functions, in other words our types are expanded thusly:\n      <ul>\n      <li> (<i>a</i> → <i>b</i>) </li>\n      </ul>\n      And (<i>a</i> → <i>b</i>) {\"≤\"} (<i>a{\"'\"}</i> → <i>b{\"'\"}</i>) iff <i>a{\"'\"}</i> {\"≤\"} <i>a</i> and <i>b</i> {\"≤\"} <i>b{\"'\"}</i>.\n      In other words a function f which is a subtype of g can accept anything that g can accept and possibly more but will return at most what g may return.\n      </p>\n</div>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/blogpost.11d1fab8.png\";","import React, { FunctionComponent, ReactElement } from 'react';\nimport BlogPostImage from './blogpost.png';\n\nimport {\n  useParams,\n  Link\n} from \"react-router-dom\";\n\ntype BlogPost = (props: {title:string, date:string, content: any, id:string}) => ReactElement<any,any>;\nconst Post: BlogPost = (props: {title:string, date:string, content: any, id:string}): ReactElement<any,any> => {\n  return (\n    <div>\n      <h3 className=\"centered-limited\"><Link to={`${props.id}`}>{props.title}</Link></h3>\n      <h3 className=\"centered-limited\">{props.date}</h3>\n    {props.content}\n    </div>\n  );\n};\n\nconst posts: {title:string, date:string, content: any, id:string}[] = [];\nconst idToPost: Map<string, any> = new Map();\n\nconst pushPost = (post:any) => {\n  posts.push(post);\n  idToPost.set(post.id, post);\n};\n\n/*\npushPost({\n  title:\"Unison - The statically typed answer to Common Lisp?]\",\n  date:\"2020-12-17\",\n  id:\"unison-cl\",\n  content: [\n    <h4 className=\"centered-limited\"> Introduction </h4>,\n    <p className = \"centered-limited\">\n  Common Lisp's claim to fame is probably its excellent support for interactive development.\nWith an interactive debugger and the full system (including compiler) available at runtime CL enables programmers to\ninteractively compile, test, and run their porgrams without ever restarting the CL process.\nAt least that's the story which CL:ers would like to tell themselves.\n    In reality, entering an undesirable state is easy and recovering from it may be difficult, with the most commonly opted for solution is to kill the process and restart from a clean slate.\n    Because of its dynamically typed nature, manual refactorings cannot be checked for correctness, and allowing for functions to be re-defined at runtime makes static analysis difficult.\n    Despite all of these flaws CL remains the favourite language for some, precisely because of the affordances that these flaws gives the user.\n    </p>,\n    <p className = \"centered-limited\">\n    Unison provides a solution (note: a solution is not a silver bullet) for these issues.\n    Unison is a statically typed, eagerly evaluated, language with algebraic effect handlers (conditions, but better).\n    What makes Unison unique is the key technical idea as listed on their website: \"Unison definitions are identified by content\".\n    Taking this idea and running with it has proven to construct a language which I believe that Lispers would find appealing.\n    The remainder of this post will mostly be regurgitation - any facts about Unison can just as well be learnt from their website - but it will be regurgitation from the perspective of a CL:er.\n    I will compare and contrast the feature set of Unison with that of Common Lisp, and what language has to learn from each other.\n    </p>,\n    <h4 className=\"centered-limited\"> Effects - conditions but better </h4>,\n    <h4 className=\"centered-limited\"> Safe refactoring </h4>,\n    <h4 className=\"centered-limited\"> Codebase management </h4>\n    ]\n});\n\npushPost({\n  title:\"Galois Connections\",\n  date:\"2020-12-17\",\n  id:\"galois-connections\",\n  content:\n  <p className = \"centered-limited\">\n  </p>\n});\n*/\n\npushPost({\n  title: \"How I run this site.\",\n  date:\"2020-12-18\",\n  id:\"how-i-run-this-site\",\n  content: [\n    <p className=\"centered-limited\">\n      This is the KISS version of running a personal site.\n      I got my css from pure-css and I run everything as a React app using gh-pages and react-scripts.\n      Every blog post is a small program which pushes a post onto an array which is then rendered by a function (I use React Hooks).\n      I treat the entire website as a program where I run whatever I want.\n      There are essentially no static assets.\n      I can whole-heartedly recommend this as a no-frills version of writing and hosting a personal site.\n    </p>,\n      <p className=\"centered-limited\">\n      Unfortunately the site takes an absurd amount of memory.\n      Loading the site can take a while, according to Firefox almost 2MB of compressed JavaScript is sent over the wire.\n      I assume that the majority of this is the libraries which I import.\n      </p>,\n    <img style={{display: \"block\"}} className=\"centered-limited\" src={BlogPostImage} alt=\"How I wrote this blog post\">\n    </img>\n  ]\n})\n\nexport const Blog = () => {\n  const { id } = useParams<{id:string}>();\n  if(id === 'all') {\n    return (\n      <div>\n\t<h2 className=\"center\">Blog</h2>\n\t{posts.reverse().map(Post)}\n      </div>\n    );\n  } else {\n    const post = idToPost.get(id);\n    if(post) {\n      return (\n\t<div>{Post(post)}</div>\n      );\n    }\n    else {\n      return (\n\t<div>\n\t  <h1 className=\"center\">Blog post not found.</h1>\n\t  </div>\n      );\n    }\n  }\n}\n","import React, { useEffect } from 'react';\nimport {\n  Route,\n  Link,\n  HashRouter,\n  Switch\n} from 'react-router-dom';\n\nimport { RelSymWasm } from './RelSymWasm';\nimport { BSc } from './BSc';\nimport { Home } from './Home';\nimport { JMM } from './JMM';\nimport { StructuralTyping } from './StructuralTyping';\nimport { Blog } from './Blog';\nimport './pure.css';\n\nfunction App() {\n  useEffect(() => {\n    document.title = 'A page.';\n  });\n  return (\n    <HashRouter>\n      <ul className=\"pure-menu-horizontal\">\n        <li className=\"pure-menu-item\"><Link className=\"pure-menu-link\" to=\"/\">Home</Link></li>\n        <li className=\"pure-menu-item\"><Link className=\"pure-menu-link\" to=\"/blog/all\">Blog</Link></li>\n        <li className=\"pure-menu-item\"><Link className=\"pure-menu-link\" to=\"/relsymwasm\">MSc thesis</Link></li>\n        <li className=\"pure-menu-item\"><Link className=\"pure-menu-link\" to=\"/bsc\">BSc thesis</Link></li>\n        <li className=\"pure-menu-item\"><Link className=\"pure-menu-link\" to=\"/jmm\">JMM (WIP)</Link></li>\n        <li className=\"pure-menu-item\"><Link className=\"pure-menu-link\" to=\"/structuraltyping\">Structural typing</Link></li>\n      </ul>\n      <Switch>\n       <Route exact path=\"/relsymwasm\" component={RelSymWasm}/>\n       <Route exact path=\"/blog/:id\" component={Blog}/>\n       <Route exact path=\"/bsc\" component={BSc}/>\n       <Route exact path=\"/jmm\" component={JMM}/>\n       <Route exact path=\"/structuraltyping\" component={StructuralTyping}/>\n       <Route exact path=\"/\" component={Home}/>\n      </Switch>\n    </HashRouter>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.css';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}